syntax = "proto3";

package menumerchantgateway;

import "common/common.proto";
import "common/service_client_config.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/wrappers.proto";
import "menu/menu.proto";

option go_package = "github.com/doordash/services-protobuf/generated/menu/menumerchantgateway/grpc";
option java_generic_services = true;
option java_multiple_files = true;
option java_package = "com.doordash.rpc.menumerchantgateway.grpc";

service MerchantGateway {
  // merchant specific read APIs. Others are same as consumer gateway now
  // more details about hermes client option definition:
  // https://github.com/doordash/dd-util-java/wiki/Hermes#service-definition
  rpc GetEntities(GetEntitiesRequest) returns (GetEntitiesResponse) {
    option (service_client.client_method_config).response_attempt_timeout_millis = 500;
    option (service_client.client_method_config).retry_config.max_attempts = 2;
    option (service_client.client_method_config).circuit_breaker_config.failure_rate_threshold = 0.8;
    option (service_client.client_method_config).circuit_breaker_config.minimum_request_threshold = 40;
    option (service_client.client_method_config).circuit_breaker_config.counter_sliding_window_millis = 5000;
    option (service_client.client_method_config).circuit_breaker_config.circuit_open_window_millis = 12000;
  }
  rpc GetEntitiesByExternalId(GetEntitiesByExternalIdRequest) returns (GetEntitiesResponse);
  rpc GetMenu(GetMenuRequest) returns (GetMenuResponse);
  rpc GetMenuV2(GetMenuRequest) returns (GetMenuResponse);

  // special hours APIs - to be removed
  rpc GetSpecialHours(GetSpecialHoursRequest) returns (GetSpecialHoursResponse);
  rpc CreateSpecialHoursBatch(CreateSpecialHoursBatchRequest) returns (CreateSpecialHoursBatchResponse);
  rpc DeleteSpecialHoursBatch(DeleteSpecialHoursBatchRequest) returns (DeleteSpecialHoursBatchResponse);

  // catering related APIs
  rpc GetCateringMenu(GetCateringMenuRequest) returns (GetCateringMenuResponse);
  rpc UpsertCateringMenu(UpsertCateringMenuRequest) returns (UpsertCateringMenuResponse);

  // write APIs
  rpc UpsertMenuStructure(UpsertMenuStructureRequest) returns (UpsertMenuStructureResponse);
  rpc UpsertMenuMeta(UpsertMenuMetaRequest) returns (UpsertMenuMetaResponse);
  rpc UpsertEntity(UpsertEntityRequest) returns (UpsertEntityResponse);
  rpc UpsertEntities(UpsertEntitiesRequest) returns (UpsertEntitiesResponse);
  rpc DeleteEntity(stream UpsertEntityRequest) returns (stream DeleteEntityResponse);
  rpc CloneMenu(CloneStoreMenuRequest) returns (CloneStoreMenuResponse);
  rpc UpsertMenus(UpsertMenusRequest) returns (UpsertMenusResponse);
  rpc UpdateMenus(UpdateMenusRequest) returns (UpdateMenusResponse);
  rpc PatchMenus(PatchMenusRequest) returns (PatchMenusResponse);
  rpc DeleteMenus(DeleteMenusRequest) returns (DeleteMenusResponse);

  // suspension APIs
  rpc SuspendUnary(SuspendRequest) returns (SuspendResponse);
  rpc UnsuspendUnary(UnsuspendRequest) returns (UnsuspendResponse);
  rpc SuspendBatch(SuspendBatchRequest) returns (SuspendBatchResponse);
  rpc SuspendBatchV2(SuspendBatchRequestV2) returns (SuspendBatchResponse);
  rpc UnsuspendBatch(UnsuspendBatchRequest) returns (UnsuspendBatchResponse);
  rpc UnsuspendBatchV2(UnsuspendBatchRequestV2) returns (UnsuspendBatchResponse);
  rpc GetActiveSuspensions(GetActiveSuspensionsRequest) returns (GetActiveSuspensionsResponse);
  rpc GetAllSuspensions(GetAllSuspensionsRequest) returns (GetAllSuspensionsResponse);
  rpc UnsuspendByStore(UnsuspendByStoreRequest) returns (UnsuspendByStoreResponse);
  rpc UnsuspendByStoreWithExclusions(UnsuspendByStoreWithExclusionsRequest) returns (UnsuspendByStoreWithExclusionsResponse);
  rpc GetSuspension(GetSuspensionRequest) returns (GetSuspensionResponse);

  // search APIs
  rpc searchEntity(SearchEntityRequest) returns (SearchEntityResponse);
  rpc searchEntityV2(SearchEntityRequestV2) returns (SearchEntityResponse);
  rpc SearchItem(SearchItemRequest) returns (SearchItemResponse);

  // store and menu special hours APIs
  rpc GetStoreSpecialHours(GetStoreSpecialHoursRequest) returns (GetStoreSpecialHoursResponse);
  rpc GetAggregatedMenuHours(GetAggregatedMenuHoursRequest) returns (GetAggregatedMenuHoursResponse);
  rpc CreateStoreSpecialHoursBatch(CreateStoreSpecialHoursBatchRequest) returns (CreateStoreSpecialHoursBatchResponse);
  rpc DeleteStoreSpecialHoursBatch(DeleteStoreSpecialHoursBatchRequest) returns (DeleteStoreSpecialHoursBatchResponse);
  rpc ValidateStoreSpecialHoursBatch(CreateStoreSpecialHoursBatchRequest) returns (ValidateStoreSpecialHoursBatchResponse);
  rpc PreviewStoreSpecialHoursBatch(CreateStoreSpecialHoursBatchRequest) returns (PreviewStoreSpecialHoursBatchResponse);

  // sticky change APIs
  rpc GetStickyChangeByStoreIdEntityId(GetStickyChangeByStoreIdEntityIdRequest) returns (GetStickyChangeByStoreIdEntityIdResponse);
  rpc GetStickyChangeByStoreIdEntityIds(GetStickyChangeByStoreIdEntityIdsRequest) returns (GetStickyChangeByStoreIdEntityIdsResponse);
  rpc GetStickyChangesByStoreId(GetStickyChangesByStoreIdRequest) returns (GetStickyChangesByStoreIdResponse);

  // shared menu APIs
  rpc UpdateMenuAcrossStores(UpdateMenuAcrossStoresRequest) returns (UpdateMenuAcrossStoresResponse);
  rpc GetUpdateMenuAcrossStoresStatus(GetUpdateMenuAcrossStoresStatusRequest) returns (GetUpdateMenuAcrossStoresStatusResponse);
  rpc StartMenuSyncWorkflows(StartMenuSyncWorkflowsRequest) returns (StartMenuSyncWorkflowsResponse);

  // shared modifier APIs
  rpc UpdateModifierAcrossStores(UpdateModifierAcrossStoresRequest) returns (UpdateModifierAcrossStoresResponse);
  rpc GetUpdateModifierAcrossStoresStatus(GetUpdateModifierAcrossStoresStatusRequest) returns (GetUpdateModifierAcrossStoresStatusResponse);

  // experiment table read/write APIs
  rpc GetExperiments(GetExperimentsRequest) returns (GetExperimentsResponse);
  rpc SaveExperiments(SaveExperimentsRequest) returns (SaveExperimentsResponse);

  // Design doc: go/rx-menu-validation-api
  rpc ValidateMenu(ValidateMenuRequest) returns (ValidateMenuResponse);

  // Photo APIs
  rpc UpdatePhotoLinks(UpdatePhotoLinksRequest) returns (UpdatePhotoLinksResponse);
  rpc SearchPhotos(SearchPhotoRequest) returns (SearchPhotoResponse);
}

/**
 * Request to create multiple photo links to store menu items
 */
message UpdatePhotoLinksRequest {
  repeated UpdatePhotoLinkRequest requests = 1;
}

/**
 * Request to create photo link to menu item
 */
message UpdatePhotoLinkRequest {
  // The entity that will be updated
  menu.EntityPosition entity_position = 1;

  // The ImageInfo field to be updated
  menu.ImageInfo image_info = 2;

  // The PhotoExperiment field to be updated
  menu.OverridableImageInfo photo_experiment = 3;
}

/**
 * Response of creating photo link to menu item
 */
message UpdatePhotoLinksResponse {
  repeated UpdatePhotoLinkRequest failed_requests = 1;
}

/**
 * Store menu level fetch options
 */
message FetchOptions {
  bool meta = 1;
  bool structure = 2;
  bool dag = 3;
  bool entities = 4;
  bool index = 5;
  bool validation = 6;
  bool menus = 7;
  bool categories = 8;
  bool sticky = 89;
}

// message to hold menu level filtering such as channel based filtering
message MenuFetchOptions {
  /*
   * The default GetMenu response will only return the normal menus and the channel-based menus. thus, union menus are not returned
   * If include_union_menus = true, it will return all the menus, including the normal menus, channel-based (derived) menus and union menus.
   * FYI: the top items of a shared category will be the union of the top items of the same category across different menus.
   */
  bool include_union_menus = 1;
}

/**
 * Request to upsert some menus
 * store_menu_id: store menu id
 * menus: menus to update
 * delete_inactive_menu: delete inactive menus or not
 * read_time: read time lock
 */
message UpsertMenusRequest {
  string store_menu_id = 1;
  menu.StoreMenu menus = 2;
  bool delete_inactive_menu = 3;
  int64 read_time = 4;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Request to patch menus and entities
 * store_menu_id: store menu id to patch
 * menus: menus to patch
 * read_time: read time lock
 */
message PatchMenusRequest {
  string store_menu_id = 1;
  menu.StoreMenu menus = 2;
  int64 read_time = 3;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Response of patch menus
 */
message PatchMenusResponse {}

/**
 * Request to delete menus
 * store_menu_id: store menu id to patch
 * menu_ids: menus to patch
 * read_time: read time lock
 */
message DeleteMenusRequest {
  string store_menu_id = 1;
  repeated string menu_ids = 2;
  int64 read_time = 3;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Response of patch menus
 */
message DeleteMenusResponse {}

/**
 * Return of uperting some menus
 */
message UpsertMenusResponse {}

/**
 * Request to update menus
 * store_menu_id: store menu id
 * structure: menu structure
 * meta: store menu meta
 * entity_maps: entity maps
 * read_time: read time lock
 */
message UpdateMenusRequest {
  string store_menu_id = 1;
  menu.MenuStructure structure = 2;
  menu.MenuMeta meta = 3;
  menu.EntityMaps entity_maps = 4;
  int64 read_time = 5;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Return of update menus
 */
message UpdateMenusResponse {}

/**
 * Request to get item or extra
 * serve_time: menu serve time to render entity, e.g. schedule order. If empty, system will use current time.
 * entity_position: position data - store_menu_id, menu_id, category_id, top_item_id, parent_id, entity_id and entity_type
 * do_recursion: if true, returned items/extras are populated recursively with all levels of extras and options. Otherwise, returned items/extras have itself and next level only.
 * do_assembly: if true, assembled item or extra is returned in entity maps. otherwise, un-assembled entities are returned in entity maps.
 * include_meta: if true, include the store menu meta
 * global_contexts: global context like experience, service type etc
 * include_archived_entities: include soft deleted entities or not
 * recursion_mode: recursion_mode to decide how deep to fetch
 * do_reverse_recursion: if true, recursion to find parents when top item is available
 */
message GetEntityRequest {
  int64 serve_time = 1;
  menu.EntityPosition entity_position = 2;
  // do_recursion deprecate using recursion_mode instead
  bool do_recursion = 3;
  bool do_assembly = 4;
  bool include_meta = 5;
  repeated menu.Context global_contexts = 6;
  bool include_archived_entities = 7;
  RecursionMode recursion_mode = 8;
  bool do_reverse_recursion = 9;
  // flag to skip suspension call in the getEntities flow
  bool should_skip_suspension = 10;
}

/**
 * Request to get item or extra by external id
 */
message GetEntityByExternalIdRequest {
  int64 serve_time = 1;
  string store_menu_id = 2;
  string merchant_supplied_id = 3;
  bool do_assembly = 4;
  bool include_meta = 5;
  repeated menu.Context global_contexts = 6;
  bool include_archived_entities = 7;
  RecursionMode recursion_mode = 8;
  bool do_reverse_recursion = 9;
  // flag to skip suspension call in the getEntities flow
  bool should_skip_suspension = 10;
}

/**
 * Return of getting item or extra
 * id: entity id
 * status: error message
 * entity_maps: container of items or extras
 * meta: store menu meta data
 */
message GetEntityResponse {
  string id = 1;
  menu.Status status = 2;
  menu.EntityMaps entity_maps = 3;
  menu.MenuMeta meta = 4;
}

/**
 * array of GetEntityRequest
 * get_entities_request: GetEntityRequest array
 */
message GetEntitiesRequest {
  repeated GetEntityRequest get_entities_request = 1;
}

/**
 * array of GetEntitiesResponse
 * get_entities_request: GetEntitiesResponse array
 */
message GetEntitiesResponse {
  repeated GetEntityResponse get_entities_response = 1;
}

/**
 * array of GetEntityByExternalIdRequest
 * get_entities_by_external_id_request: GetEntitiesByExternalIdRequest array
 */
message GetEntitiesByExternalIdRequest {
  repeated GetEntityByExternalIdRequest get_entities_by_external_id_request = 1;
}

/**
 * Request to upsert menu structure such menus, categories etc.
 * read_time: menu structure last update time, which is used to handle read write race condition.
 * menu_structure: new menu structure
 * store_menu_id: store menu id
 */
message UpsertMenuStructureRequest {
  int64 read_time = 1;
  menu.MenuStructure menu_structure = 2;
  string store_menu_id = 3;
  bool enable_shared_entities = 4;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Return of upsert menu structure requests
 */
message UpsertMenuStructureResponse {}

/**
 * Request to upsert menu meta such as store menu level info
 * read_time: menu last update time, which is used to handle read write race condition.
 * menu_meta: new menu meta
 * store_menu_id: store menu id
 */
message UpsertMenuMetaRequest {
  int64 read_time = 1;
  menu.MenuMeta menu_meta = 2;
  string store_menu_id = 3;
  google.protobuf.BoolValue should_update_full_meta = 4;
}

/**
 * Return of upsert menu meta requests
 */
message UpsertMenuMetaResponse {}

/**
 * Request to upsert item or extra
 * read_time: entity last update time, which is used to handle read write race condition.
 * entity: new item or extra
 * entity_position: position data - store_menu_id, menu_id, category_id, top_item_id, parent_id, entity_id and entity_type
 */
message UpsertEntityRequest {
  int64 read_time = 1;
  menu.EntityMaps entity_maps = 2;
  menu.EntityPosition entity_position = 3;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Batch Request to upsert item or extra
 * upsert_entity_requests: upsert entity requests
 */
message UpsertEntitiesRequest {
  repeated UpsertEntityRequest upsert_entity_requests = 1;
}

/**
 * Return of upsert entity requests
 */
message UpsertEntityResponse {}

/**
 * Return of batch upsert entity requests
 */
message UpsertEntitiesResponse {
  repeated UpsertEntityResponse upsert_entity_responses = 1;
}

/**
 * Request to delete item or extra
 * read_time: entity last update time, which is used to handle read write race condition.
 * entity_position: position data - store_menu_id, menu_id, category_id, top_item_id, parent_id, entity_id and entity_type
 */
message DeleteEntityRequest {
  int64 read_time = 1;
  menu.EntityPosition entity_position = 2;
}

/**
 * Return of deleting entity requests
 */
message DeleteEntityResponse {}

/**
 * Request to suspend store menu, menu, category, item, extra or option
 * store_menu_id: store menu id
 * entity_id: id of store menu, menu, category, item, extra or option
 * entity_type: entity type
 * suspension: suspension defines to suspension expiration time and reason
 * override_suspension: allows to override with a suspension the suspended entity
 */
message SuspendRequest {
  string store_menu_id = 1;
  string entity_id = 2;
  menu.EntityType entity_type = 3;
  menu.Suspension suspension = 4;
  bool override_suspension = 5;
}

/**
 * Request to suspend category, item, extra or option
 * store_menu_id: store id
 * product_identifier: internal or external reference to the entity
 * entity_type: entity type
 * suspension: suspension defines to suspension expiration time and reason
 */
message SuspendRequestV2 {
  string store_menu_id = 1;
  MerchantProductIdentifier product_identifier = 2;
  menu.EntityType entity_type = 3;
  menu.Suspension suspension = 4; // field is ignored for unsuspension request
}

// cannot use product identifier in mpg due to it saying item_id rather than being entity agnostic
message MerchantProductIdentifier {
  // product id to represent the identifier
  oneof id {
    // internal id that doordash generates for the entity
    string internal_doordash_id = 1;
    // merchant supplied id
    string merchant_supplied_id = 2;
  }
}

/**
 * Return of suspend requests
 */
message SuspendResponse {}

/**
 * Suspend batch requests
 */
message SuspendBatchRequest {
  repeated SuspendRequest suspend_batch_request = 1;
}

/**
 * Suspend batch responses
 */
message SuspendBatchResponse {
  repeated SuspendResponse suspend_batch_response = 1;
}

// request to suspend if client doesnt know the internal reference to an entity
// client logic to map internal reference can become outdated or non-efficient so bring control to us
message SuspendBatchRequestV2 {
  repeated SuspendRequestV2 suspend_batch_request = 1;
}

/**
 * Request to unsuspend store menu, menu, category, item, extra or option
 * store_menu_id: store menu id
 * entity_id: id of store menu, menu, category, item, extra or option
 * entity_type: entity type
 */
message UnsuspendRequest {
  string store_menu_id = 1;
  string entity_id = 2;
  menu.EntityType entity_type = 3;
}

/**
 * Return of unsuspend requests
 */
message UnsuspendResponse {}

/**
 * Unsuspend batch requests
 */
message UnsuspendBatchRequest {
  repeated UnsuspendRequest unsuspend_batch_request = 1;
}

// request to un-suspend if client doesnt know the internal reference to an entity
message UnsuspendBatchRequestV2 {
  repeated SuspendRequestV2 unsuspend_batch_request = 1;
}

/**
 * Unsuspend batch responses
 */
message UnsuspendBatchResponse {
  repeated UnsuspendResponse unsuspend_batch_response = 1;
}

/**
 * Request to remove temp and perm suspensions for store
 */
message UnsuspendByStoreRequest {
  string store_menu_id = 1;
}

/**
 * Return of unsuspend by store request
 */
message UnsuspendByStoreResponse {}

/**
 * Request to remove temp and perm suspensions for store
 * excluding suspensions with given reason
 */
message UnsuspendByStoreWithExclusionsRequest {
  string store_menu_id = 1;
  repeated string reasons_to_exclude = 2;
}

/**
 * Return of unsuspend by store wit exclusion request
 */
message UnsuspendByStoreWithExclusionsResponse {}

/**
 * Request to clone store menu
 * store_menu_id: store menu id
 */
message CloneStoreMenuRequest {
  string store_menu_id = 1;
  string new_store_menu_id = 2;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
 * Return of clone store menu request
 */
message CloneStoreMenuResponse {}

// SearchBy to list the searchable keys
enum SearchBy {
  // unknown
  SEARCH_BY_UNSPECIFIED = 0;
  // title
  SEARCH_BY_TITLE = 1;
  // id
  SEARCH_BY_ID = 2;
  // description
  SEARCH_BY_DESCRIPTION = 3;
  // photo id
  SEARCH_BY_PHOTO_ID = 4;
  // external id
  SEARCH_BY_EXTERNAL_ID = 5;
  // business id
  SEARCH_BY_BUSSINESS_ID = 6;
  // menu id
  SEARCH_BY_MENU_ID = 7;
  // store id
  SEARCH_BY_STORE_ID = 8;
  // is active
  // used to lookup entities by active status: boolean type
  SEARCH_BY_IS_ACTIVE = 9;
}

// search parameter
message SearchParam {
  SearchBy search_by = 1;
  // value used to search
  oneof search_value {
    google.protobuf.StringValue string_search_value = 2;
    google.protobuf.BoolValue boolean_search_value = 3;
    google.protobuf.Int32Value integer_search_value = 4;
  }
  bool do_exact_match = 5;
}

// partial search type
enum PartialSearchType {
  // unknown
  PARTIAL_SEARCH_TYPE_UNSPECIFIED = 0;
  // prefix search for the popup menu (search-as-you-type)
  PARTIAL_SEARCH_TYPE_PREFIX_SEARCH_AS_YOU_TYPE = 1;
  // prefix search for main content page (all results)
  PARTIAL_SEARCH_TYPE_PREFIX_SEARCH_ALL_RESULTS = 2;
}

// different option filtering modes
enum OptionFilteringMode {
  // default, no filtering on option, returned results will include option
  OPTION_FILTERING_MODE_UNSPECIFIED = 0;
  // filter out option in the returned results
  OPTION_FILTERING_MODE_FILTER_OUT_OPTION = 1;
  // only fetch for option
  OPTION_FILTERING_MODE_RETURN_OPTION_ONLY = 2;
}

/**
 * Request to search entities
 * store_menu_id: store menu id. If empty, search across store menus
 * search_param: search keys used to each entity
 * entity_type: entity type enum. If empty, search across entity types
 * do_or_query: use OR condition in search params, default is AND condition
 * page_start: start position
 * page_end: end position
 * do_filter_option: DEPRECATED, please use option_filtering_mode instead
 * do_filter_orderable: filter orderable or not when search top item only
 * option_filtering_mode: different option filtering modes
 * partial_search_type: to define the partial search type
 */
message SearchEntityRequest {
  google.protobuf.StringValue store_menu_id = 1;
  repeated SearchParam search_params = 2;
  menu.EntityType entity_type = 3;
  bool do_or_query = 4;
  google.protobuf.Int32Value page_start = 5;
  google.protobuf.Int32Value page_end = 6;
  bool do_filter_option = 7 [deprecated = true];
  bool do_filter_orderable = 8;
  bool do_skip_menu_fetch = 9;
  OptionFilteringMode option_filtering_mode = 10;
  PartialSearchType partial_search_type = 11;
}

/**
   Setting up conditions for current SearchParam
*/
message SearchCondition {
  repeated SearchParam search_params = 1;
  bool do_or_query = 2;
}

/**
 * Request to search entities
 * store_menu_id: store menu id. If empty, search across store menus
 * search_conditions: list of SearchParam and condition for SearchParam
 * entity_type: entity type enum. If empty, search across entity types
 * do_or_query: use OR condition in search params, default is AND condition
 * page_start: start position
 * page_end: end position
 * do_filter_option: search top item only or not
 * do_filter_orderable: filter orderable or not when search top item only
 * option_filtering_mode: different option filtering modes
 * partial_search_type: to define the partial search type
 * results_limit: limit the number of results returned (Details: https://docs.google.com/document/d/1687_YfCPCgn9opZx5x9XYK9IThUdl91yL0c8eZaO_p0)
 */
message SearchEntityRequestV2 {
  google.protobuf.StringValue store_menu_id = 1;
  repeated SearchCondition search_conditions = 2;
  menu.EntityType entity_type = 3;
  bool do_or_query = 4;
  google.protobuf.Int32Value page_start = 5;
  google.protobuf.Int32Value page_end = 6;
  bool do_filter_option = 7;
  bool do_filter_orderable = 8;
  bool do_skip_menu_fetch = 9;
  OptionFilteringMode option_filtering_mode = 10;
  PartialSearchType partial_search_type = 11;
  google.protobuf.Int32Value results_limit = 12;
}

/**
 * search entity
 **/
message SearchResult {
  string store_menu_id = 1;
  // searched entity
  oneof entity {
    menu.Item item = 2;
    menu.Extra extra = 3;
    menu.Menu menu = 4;
    menu.Category category = 5;
  }
}

/**
 * Return of searching item or extra
 * searchEntities: search result list
 * total_count: total count of search result
 * page_start: start position
 * page_end: end position
 */
message SearchEntityResponse {
  repeated SearchResult search_results = 1;
  int32 total_count = 2;
  int32 page_start = 3;
  int32 page_end = 4;
}

// Search item request with custom logic for promotion use cases.
message SearchItemRequest {
  string business_id = 1; // Filter business_id.
  repeated string store_menu_ids = 2; // Filter list of store_menu_ids.
  repeated common.Experience experiences = 3; // Filter the given experiences, or no-op when empty.
  string item_title = 4; // Partial search in the item_title, return first N items when empty.
  int32 page_start = 5;
  int32 page_end = 6; // Assume page_start <= page_end.
}

// Search item response
message SearchItemResponse {
  // Search result
  message Result {
    string store_menu_id = 1;
    menu.Item item = 2;
  }

  repeated Result results = 1;
  int32 total_count = 2;
  int32 page_start = 3;
  int32 page_end = 4;
}

// Search ES item document request with custom logic for photo related use cases.
// only returns top level items atm, optionFilteringMode field can be added later to support options with missing photos
message SearchPhotoRequest {
  string store_menu_id = 1; // Filter items within this storeId
  string menu_id = 2; // Filter items within this menuId
  google.protobuf.StringValue title = 3; // Filter items containing title value (how strict the value matching depends on matchingRequirement value)
  google.protobuf.StringValue description = 4; // Filter items containing description value (how strict the value matching depends on matchingRequirement value)
  // needs to be populated if you pass in a title or description value
  TextSearchType text_search_type = 5;
  // determine the type of photo constraints you want to specify for item
  PhotoSearchType photo_search_type = 6;
  // pagination start location
  int32 page_start = 7;
  // pagination end location
  google.protobuf.Int32Value page_end = 8;
  // determine to call getEntities or not; getEntities fetches the complete item data
  bool should_fetch_complete_item_data = 9;
}

// search photo response
message SearchPhotoResponse {
  // map containing the complete item info or just the an item message with the id populated
  map<string, menu.Item> item_map = 1;
  // total entries of the original ES search result without pagination logic
  int32 total_count = 2;
  // pagination info
  int32 page_start = 3;
  // pagination info
  google.protobuf.Int32Value page_end = 4;
}

// default will be exact match
enum TextSearchType {
  // unknown
  TEXT_SEARCH_TYPE_UNSPECIFIED = 0;
  // value needs to be an EXACT match (string1 == string2)
  TEXT_SEARCH_TYPE_EXACT = 1;
  // value needs to atleast match on a partial token (word). not partial letters within a word
  TEXT_SEARCH_TYPE_TOKENIZE = 2;
}

// default will be missing photos
enum PhotoSearchType {
  // unknown
  PHOTO_SEARCH_TYPE_UNSPECIFIED = 0;
  // if photoId does not exist in item (empty or null)
  PHOTO_SEARCH_TYPE_MISSING = 1;
  // if item contains a photoId that is rejected
  PHOTO_SEARCH_TYPE_REJECTED = 2;
  // return items with missing photos or with photoIds that are rejected
  PHOTO_SEARCH_TYPE_MISSING_OR_REJECTED = 3;
}

// RecursionMode to decide how deep of nested structure of entity to be fetched
enum RecursionMode {
  // unknown
  RECURSION_MODE_UNSPECIFIED = 0;
  // no recursion, just base entity
  RECURSION_MODE_NO_RECURSION = 1;
  // base entity and all children
  RECURSION_MODE_DEEP_RECURSION = 2;
  // base entity and immediate children
  RECURSION_MODE_RECURSION_ONE = 3;
  // base entity and immediate children + 1 more level
  RECURSION_MODE_RECURSION_TWO = 4;
}

/**
 * Request to get menu structure and selected menu items
 * serve_time: menu serve time used to render entities, e.g. schedule order. If empty, system will use current time.
 * store_menu_id: store menu id
 * selected_menu_ids: selected menus to be populated with items. If empty, system will choose a menu based on menu hours and serve time.
 * include_menu_structure_only: if true, return menus and categories only without items.
 * do_recursion: if true, returned items are populated recursively with all levels of extras and options. Otherwise, returned items have item level info only.
 * do_assembly: if true, assembled entities are returned with items. otherwise, un-assembled entities with override rules are returned in entity maps of store_menu.
 * global_contexts: global context like experience, service type etc
 * include_dag_only: return the dag only
 * include_archived_entities: include soft deleted entities or not
 * fetch_options: choose the menu info to fetch
 * recursion_mode: recursion_mode to decide how deep to fetch
 */
message GetMenuRequest {
  int64 serve_time = 1;
  string store_menu_id = 2;
  repeated string selected_menu_ids = 3;
  // include_menu_structure_only deprecate using fetch_options.structure instead
  bool include_menu_structure_only = 4;
  // do_recursion deprecate using recursion_mode instead
  bool do_recursion = 5;
  bool do_assembly = 6;
  repeated menu.Context global_contexts = 7;
  // include_dag_only deprecate using fetch_options.dag instead
  bool include_dag_only = 8;
  bool include_archived_entities = 9;
  FetchOptions fetch_options = 10;
  RecursionMode recursion_mode = 11;
  // flag that determines if we should skip the suspension call during getMenu
  bool should_skip_suspension = 12;
  // determines if union menu content will be returned; only normal and derived channel menu content will be returned by default
  MenuFetchOptions menu_fetch_options = 13;
}

/**
 * Return of getting menu structure and selected menu items
 * loaded_menu_ids: ids of menu with loaded items
 * store_menu: populated store menu
 */
message GetMenuResponse {
  repeated string loaded_menu_ids = 1;
  menu.StoreMenu store_menu = 2;
}

// catering menu is imaginary but still store bounded so only storeId is required to fetch the catering data
message GetCateringMenuRequest {
  // required if fetching suspension is needed
  int64 serve_time = 1;
  // store id that contains catering catalog
  string store_menu_id = 2;
  // determines how much of the remaining catering catalog we need to fetch
  EntityFetchType entity_fetch_type = 3;
  // determine if we skip suspension retrieval or not
  bool should_skip_suspension = 4;
}

// contains all catering entities (categories/items/extras/options)
message GetCateringMenuResponse {
  // storeMenu object containing catering catalog
  menu.StoreMenu store_menu = 1;
}

// determines the level of entities we need to fetch for StoreMenu
enum EntityFetchType {
  // unspecified; treated as none
  ENTITY_FETCH_TYPE_UNSPECIFIED = 0;
  // do not fetch entities from the catering catalog
  ENTITY_FETCH_TYPE_NONE = 1;
  // fetch only the top level items from the catering catalog
  ENTITY_FETCH_TYPE_ITEMS = 2;
  // fetch all entities from the catering catalog
  ENTITY_FETCH_TYPE_ITEMS_EXTRAS_OPTIONS = 3;
}

// request to update or create a catering menu under a store
message UpsertCateringMenuRequest {
  // storeId of the catering menu
  string store_menu_id = 1;
  // storeMenu object containing catering catalog to update
  menu.StoreMenu store_menu = 2;
  int64 read_time = 3;
}

// response of a catering menu ingestion request
message UpsertCateringMenuResponse {}

// suspension entity
message SuspensionEntity {
  string id = 1;
  string store_menu_id = 2;
  string entity_id = 3;
  menu.EntityType entity_type = 4;
  menu.Suspension suspension = 5;
  // determines whether the suspension is soft deleted; ; null value also signifies active suspension
  google.protobuf.BoolValue is_active = 6;
}

/**
 * Request to get active suspensions
 * store_menu_id: store menu id
 * at_time: the timestamp to check if active
 */
message GetActiveSuspensionsRequest {
  string store_menu_id = 1;
  int64 at_time = 2;
  repeated string entity_ids = 3;
}

/**
 * Response to get active suspensions
 * entities: active suspensions for a store
 */
message GetActiveSuspensionsResponse {
  repeated SuspensionEntity entities = 1;
}

/**
 * Request to get all suspensions for a store
 * store_menu_id: store menu id
 * entity_ids: list of entity IDs to filter by (optional)
 */
message GetAllSuspensionsRequest {
  string store_menu_id = 1;
  repeated string entity_ids = 2;
}

/**
 * Response to get all suspensions
 * entities: suspensions for a store
 */
message GetAllSuspensionsResponse {
  repeated SuspensionEntity entities = 1;
}

/**
 * Request to get entity suspension
 * store_menu_id: store menu id
 * entity_id: entity id
 */
message GetSuspensionRequest {
  string store_menu_id = 1;
  string entity_id = 2;
}

/**
 * Response to get active suspensions
 * suspension_entity: suspension entity
 */
message GetSuspensionResponse {
  SuspensionEntity suspension_entity = 1;
}

/**
 * create store special hours batch request
 */
message CreateStoreSpecialHoursBatchRequest {
  repeated CreateStoreSpecialHoursRequest requests = 1;
}

/**
 * create store special hours batch response
 */
message CreateStoreSpecialHoursBatchResponse {
  repeated CreateStoreSpecialHoursResponse responses = 1;
}

/**
 * validate store special hours batch response
 */
message ValidateStoreSpecialHoursBatchResponse {
  repeated ValidateStoreSpecialHoursResponse responses = 1;
}

/**
 * Preview store special hours batch response
 */
message PreviewStoreSpecialHoursBatchResponse {
  repeated PreviewStoreSpecialHoursResponse special_hour_previews = 1;
  repeated ValidateStoreSpecialHoursResponse special_hour_validations = 2;
}

/**
 * create store special hours request
 */
message CreateStoreSpecialHoursRequest {
  string store_menu_id = 1;
  repeated menu.HoursException special_hour = 3;
}

/**
 * create store special hours response
 */
message CreateStoreSpecialHoursResponse {
  menu.Status status = 1;
}

/**
 * validate store special hours response
 */
message ValidateStoreSpecialHoursResponse {
  string store_menu_id = 1;
  repeated menu.HoursExceptionWithValidation special_hour_with_validation = 2;
}

/**
 * preview store special hours response
 */
message PreviewStoreSpecialHoursResponse {
  string store_menu_id = 1;
  repeated menu.HoursException preview_special_hour = 2;
}

/**
 * delete store special hours batch request
 */
message DeleteStoreSpecialHoursBatchRequest {
  repeated DeleteStoreSpecialHoursRequest requests = 1;
}

/**
 * delete store special hours batch response
 */
message DeleteStoreSpecialHoursBatchResponse {
  repeated DeleteStoreSpecialHoursResponse response = 1;
}

/**
 * delete store special hours request
 */
message DeleteStoreSpecialHoursRequest {
  string store_menu_id = 1;
  repeated menu.HoursException special_hour = 2;
}

/**
 * delete store special hours response
 */
message DeleteStoreSpecialHoursResponse {
  menu.Status status = 1;
}

/**
 * get store special hours request
 */
message GetStoreSpecialHoursRequest {
  string store_menu_id = 1;
  bool active_only = 2;
}

/**
 * get store special hours response
 */
message GetStoreSpecialHoursResponse {
  repeated menu.HoursException special_hour = 1;
}

/**
 * get aggregated menu hours request
 */
message GetAggregatedMenuHoursRequest {
  string store_menu_id = 1;
  bool active_only = 2;
}

/**
 * get aggregated menu hours response
 */
message GetAggregatedMenuHoursResponse {
  repeated menu.HoursException store_special_hours = 1;
  repeated AggregatedMenuHoursInfo aggregated_menu_hours = 2;
}

/**
 * aggregated menu hours info
 */
message AggregatedMenuHoursInfo {
  string menu_id = 1;
  repeated menu.Hours menu_hours = 2;
  repeated menu.HoursException menu_special_hours = 3;
  repeated menu.HoursException store_menu_intersected_hours = 4;
}

/**
 * Request to get menu sticky change by store id and entity id
 */
message GetStickyChangeByStoreIdEntityIdRequest {
  string store_menu_id = 1;
  string entity_id = 2;
}

/**
 * Return of getting menu sticky change by store id and entity id
 */
message GetStickyChangeByStoreIdEntityIdResponse {
  menu.MenuStickyChange menu_sticky_change = 1;
}

/**
 * Request to get menu sticky changes by entity_ids under the same store_menu_id
 */
message GetStickyChangeByStoreIdEntityIdsRequest {
  string store_menu_id = 1;
  repeated string entity_ids = 2;
}

/**
 * Return of getting menu sticky changes by entity_ids under the same store_menu_id
 */
message GetStickyChangeByStoreIdEntityIdsResponse {
  repeated menu.MenuStickyChange menu_sticky_changes = 1;
}

/**
 * Request to get menu sticky change by store id
 */
message GetStickyChangesByStoreIdRequest {
  string store_menu_id = 1;
}

/**
 * Return of getting menu sticky change by store id
 */
message GetStickyChangesByStoreIdResponse {
  repeated menu.MenuStickyChange menu_sticky_changes = 1;
}

/**
 * create special hours batch request
 */
message CreateSpecialHoursBatchRequest {
  repeated CreateSpecialHoursRequest requests = 1;
}

/**
 * create special hours batch response
 */
message CreateSpecialHoursBatchResponse {
  repeated CreateSpecialHoursResponse responses = 1;
}

/**
 * create special hours request
 */
message CreateSpecialHoursRequest {
  string store_menu_id = 1;
  string menu_id = 2;
  repeated menu.HoursException special_hour = 3;
}

/**
 * create special hours response
 */
message CreateSpecialHoursResponse {
  menu.Status status = 1;
}

/**
 * delete special hours batch request
 */
message DeleteSpecialHoursBatchRequest {
  repeated DeleteSpecialHoursRequest requests = 1;
}

/**
 * delete special hours batch response
 */
message DeleteSpecialHoursBatchResponse {
  repeated DeleteSpecialHoursResponse response = 1;
}

/**
 * delete special hours request
 */
message DeleteSpecialHoursRequest {
  string store_menu_id = 1;
  string menu_id = 2;
  repeated menu.HoursException special_hour = 3;
}

/**
 * delete special hours response
 */
message DeleteSpecialHoursResponse {
  menu.Status status = 1;
}

/**
 * get special hours request
 */
message GetSpecialHoursRequest {
  string store_menu_id = 1;
  bool active_only = 2;
}

/**
 * get special hours response
 */
message GetSpecialHoursResponse {
  repeated menu.HoursException special_hour = 1;
}

// UpdateMenuAcrossStores
/**
 * Request to update menus
 * menu_id: menu id
 * structure: menu structure
 * meta: store menu meta
 * entity_maps: entity maps
 * read_time: read time lock
 */
message UpdateMenuAcrossStoresRequest {
  string menu_id = 1;
  menu.MenuStructure structure = 2;
  // menu.MenuMeta meta = 3;
  menu.EntityMaps entity_maps = 4;
  int64 read_time = 5;
  repeated string reverse_sync_menu_id_list = 40 [deprecated = true];
}

/**
   UpdateMenuAcrossStoresResponse
*/
message UpdateMenuAcrossStoresResponse {
  string check_status_id = 1;
}

/**
   GetUpdateMenuAcrossStoresStatusRequest
*/
message GetUpdateMenuAcrossStoresStatusRequest {
  string check_status_id = 1;
}

/**
   update_status_map key is storeId, val is update status
   For overall_status, status_code will be more generic, for example: WORKFLOW_STATUS_SUCCESS, WORKFLOW_STATUS_FAILURE, WORKFLOW_STATUS_PARTIAL_SUCCESS
   For update_status_map, status_code will be more specific, for example: WORKFLOW_STATUS_FAILURE_CONCURRENT_ACCESS, WORKFLOW_STATUS_FAILURE_FAILED_PRECONDITION
   information will have the detailed error msg.
*/
message GetUpdateMenuAcrossStoresStatusResponse {
  string check_status_id = 1;
  UpdateMenuAcrossStoresStatus overall_status = 2;
  map<string, UpdateMenuAcrossStoresStatus> update_status_map = 3;
}

/**
   UpdateMenuAcrossStoresStatus
*/
message UpdateMenuAcrossStoresStatus {
  UpdateMenuAcrossStoresStatusType status_type = 1 [deprecated = true];
  string information = 2;
  WorkflowStatus status_code = 3;
}

/**
   UpdateMenuAcrossStoresStatusType
*/
enum UpdateMenuAcrossStoresStatusType {
  // UNSPECIFIED
  UPDATE_MENU_ACROSS_STORES_STATUS_TYPE_UNSPECIFIED = 0;
  // PENDING
  UPDATE_MENU_ACROSS_STORES_STATUS_TYPE_PENDING = 1;
  // IN_PROGRESS
  UPDATE_MENU_ACROSS_STORES_STATUS_TYPE_IN_PROGRESS = 2;
  // SUCCESS
  UPDATE_MENU_ACROSS_STORES_STATUS_TYPE_SUCCESS = 3;
  // FAILURE
  UPDATE_MENU_ACROSS_STORES_STATUS_TYPE_FAILURE = 4;
}

/**
   StartMenuSyncWorkflowsRequest
*/
message StartMenuSyncWorkflowsRequest {
  string store_menu_id = 1;
  repeated string menu_ids = 2;
  // whether this sync is for a menu deletion
  bool is_menu_deletion = 3;
}

/**
   StartMenuSyncWorkflowsResponse
*/
message StartMenuSyncWorkflowsResponse {}

// Known status codes for Workflows exposed to menu users
// this is essentially merchant-integrations/menu.proto#WorkflowStatus
// with minor differences; in the future both should use the same enum;
// for now this is to avoid unexpected circular dependencies between
// menu protos and merchant integration protos
enum WorkflowStatus {
  // unknown/not set
  WORKFLOW_STATUS_UNKNOWN_UNSPECIFIED = 0;
  // workflow created but not started
  WORKFLOW_STATUS_PENDING = 1;
  // workflow execution in progress
  WORKFLOW_STATUS_IN_PROGRESS = 2;
  // workflow completed successfully
  WORKFLOW_STATUS_SUCCESS = 3;
  // workflow completed satisfying partial conditions for "success"
  WORKFLOW_STATUS_PARTIAL_SUCCESS = 4;
  // invalid workflow arguments
  WORKFLOW_STATUS_FAILURE_INVALID_ARGUMENT = 5;
  // unknown workflow
  WORKFLOW_STATUS_FAILURE_NOT_FOUND = 6;
  // workflow conditions not met
  WORKFLOW_STATUS_FAILURE_FAILED_PRECONDITION = 7;
  // concurrent access
  WORKFLOW_STATUS_FAILURE_CONCURRENT_ACCESS = 8;
  // workflow not completed in time
  WORKFLOW_STATUS_FAILURE_TIMEOUT = 9;
  // generic/unknown workflow error
  WORKFLOW_STATUS_FAILURE_INTERNAL = 10;
  // workflow failed
  WORKFLOW_STATUS_FAILURE = 11;
}

/**
 * UpdateModifierAcrossStoresRequest
 */
message UpdateModifierAcrossStoresRequest {
  // Requested change to an Item
  message ItemLinkage {
    // target item
    string item_id = 1;
    // limited to ADD_LINK, ARCHIVE_LINK
    EntityActionType action_type = 2;
  }

  // Requested change to an Option
  message OptionLinkage {
    // option to consider
    menu.Item option = 1;
    // limited to ADD_ENTITY, UPDATE_ENTITY, ARCHIVE_ENTITY
    EntityActionType action_type = 2;
    // ADD_ENTITY: ignored
    // UPDATE_ENTITY: specify replaced fields; if empty then no change
    // ARCHIVE_ENTITY: ignore
    google.protobuf.FieldMask update_mask = 3;
  }

  menu.Extra extra = 1;
  // limited to ADD_ENTITY, UPDATE_ENTITY, ARCHIVE_ENTITY
  EntityActionType extra_action_type = 2;
  // ADD_ENTITY: ignored
  // UPDATE_ENTITY: specify replaced fields; if empty then no change
  // ARCHIVE_ENTITY: ignore
  google.protobuf.FieldMask update_mask = 3;

  repeated ItemLinkage item_linkage = 4;
  repeated OptionLinkage option_linkage = 5;
}

/**
 * EntityActionType:
 * specific actions performed on entity; extent of actions may vary
 * if used in multiple endpoints
 */
enum EntityActionType {
  // no action
  ENTITY_ACTION_TYPE_NONE_UNSPECIFIED = 0;
  // create entity (and link if necessary, depending on usage)
  ENTITY_ACTION_TYPE_ADD_ENTITY = 1;
  // update entity details
  ENTITY_ACTION_TYPE_UPDATE_ENTITY = 2;
  // archive entity
  ENTITY_ACTION_TYPE_ARCHIVE_ENTITY = 3;
  // add relationship only between two entities - other entity details not considered
  ENTITY_ACTION_TYPE_ADD_LINK = 4;
  // archive relationship only between two entities
  ENTITY_ACTION_TYPE_ARCHIVE_LINK = 5;
}

/**
 * UpdateModifierAcrossStoresResponse
 */
message UpdateModifierAcrossStoresResponse {
  string job_id = 1;
}

/**
 * GetUpdateModifierAcrossStoresStatusRequest
 */
message GetUpdateModifierAcrossStoresStatusRequest {
  string job_id = 1;
}

/**
 * GetUpdateModifierAcrossStoresStatusResponse
 */
message GetUpdateModifierAcrossStoresStatusResponse {
  // status of update
  message Status {
    // workflow status
    WorkflowStatus status_code = 1;
    // additional details on workflow status, especially on PARTIAL_SUCCESS
    string details = 2;
  }

  string job_id = 1;
  Status status = 2;

  // possible key template - [ET_STORE_MENU:store_menu_id]/[ET_MENU:menu_id]/../[ET_TYPE:entity_id]
  // confirm with menu platform team on expectations before using endpoint
  //
  // examples
  // - [ET_STORE_MENU:123] for status on entire StoreMenu 123
  // - [ET_STORE_MENU:123]/[ET_MENU:456] on Menu 456 under StoreMenu 123
  // longer paths such as
  //   [ET_STORE_MENU:123]/[ET_MENU:456]/[ET_CATEGORY:789]/[ET_ITEM:111]/[ET_EXTRA:222]
  // describe the specific entity at the tail end of the path
  map<string, Status> detailed_status = 3;
}

/**
   GetExperimentsRequest
*/
message GetExperimentsRequest {
  string menu_id = 1;
  repeated string entity_ids = 2;
}

/**
   GetExperimentsResponse
*/
message GetExperimentsResponse {
  repeated menu.MenuExperimentEntry menu_experiment_entries = 1;
}

/**
   SaveExperimentsRequest
*/
message SaveExperimentsRequest {
  repeated menu.MenuExperimentEntry menu_experiment_entries = 1;
}

/**
   SaveExperimentsResponse
*/
message SaveExperimentsResponse {}

// The request to validate a menu.
message ValidateMenuRequest {
  // Same as the store id.
  string store_menu_id = 1;
  string menu_id = 2;
  menu.MenuStructure structure = 3;
  menu.EntityMaps entity_maps = 4;
}

// The response from validating a menu.
message ValidateMenuResponse {
  repeated menu.ValidationError errors = 1;
}
