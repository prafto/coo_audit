syntax = "proto3";
package async_platform_callback_service.v1;

import "common/service_client_config.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

option go_package = "github.com/doordash/services-protobuf/generated/async_platform_callback_service.v1";
option java_generic_services = true;
option java_multiple_files = true;
option java_package = "com.doordash.rpc.async_platform_callback_service";

// GRPC controls to schedule callbacks back to originating service.
// https://docs.google.com/document/d/1kiRQMmNwb5-gAO1LDhh4w2Qsqm02K3p7WPZ66JmEBRg
service AsyncPlatformCallbackService {
  // Timeout after 3000 milliseconds.
  option (service_client.client_config).response_attempt_timeout_millis = 3000;
  // Make a total 4 attempts (initial + three retries).
  option (service_client.client_config).retry_config.max_attempts = 4;
  // Add RESOURCE_EXHAUSTED to the set of retriable codes.
  option (service_client.client_config).retry_config.do_retry_grpc_code = 8;
  // Break the circuit if the error rate exceeds 80%.
  option (service_client.client_config).circuit_breaker_config.failure_rate_threshold = 0.8;
  // Ignore NOT_FOUND from circuit breaker error rate calculation.
  option (service_client.client_config).circuit_breaker_config.do_ignore_grpc_code = 5;

  // Create an EventObject. An eventId will be returned.
  rpc CreateEvent(CreateEventRequest) returns (CreateEventResponse);

  // Update the trigger time of an existing EventObject.
  rpc UpdateEventTriggerTime(UpdateEventTriggerTimeRequest) returns (UpdateEventTriggerTimeResponse);

  // Get an EventObject by eventId. An event will only exist if it can be
  //   triggered.  A OneShot event will no longer exist after it is triggered,
  //   but note that a recurring event will still exist after it is triggered.
  rpc GetEvent(GetEventRequest) returns (GetEventResponse);

  // List events. This call takes more resources to fufill.  Prefer GetEvent.
  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse);

  // Removes an event before the event is triggered. An EventRun entry of
  //   "EVENT_RUN_STATUS_CANCELED" will be added. "NOT_FOUND" will be returned
  //   if the event does not exist or has already triggered.
  rpc DeleteEvent(DeleteEventRequest) returns (DeleteEventResponse);

  // List an archive of event runs that have been triggered. These will
  //   be kept for a limited time, likely only a few days.
  rpc ListEventRuns(ListEventRunsRequest) returns (ListEventRunsResponse);
}

// Status of events that will trigger.
enum EventStatus {
  // Unspecified enum, not used
  EVENT_STATUS_UNSPECIFIED = 0;
  // Initial status of a newly created event
  EVENT_STATUS_WAIT = 1;
  // Status of an event after a failure but still within retry parameters.
  EVENT_STATUS_RETRY = 2;

  reserved 3;
}

// Read-only fields assigned by the callback-service.
message EventSystemInfo {
  // A unique ID assigned to each event and specified in the incoming request
  // by the caller.
  string event_id = 1;

  // Derived from the API_KEY provided at event creation.
  string team_name = 2;

  // The intended trigger time of this event, derived from the trigger_time,
  //   recurring cron specification, jitter, and retry fields.
  //   Minor Note: NTP Clockdrift is NOT considered so the event may trigger
  //   earlier than this time by typically a few seconds. However, it is
  //   most likely that the actual trigger time will be after this time by
  //   seconds, if not a few minutes.
  google.protobuf.Timestamp adjusted_trigger_time = 3;

  // Status of the event that has not yet successfully triggered
  EventStatus event_status = 4;

  // Present if this event was generated by a recurring event, the current
  //   execution number of this event chain.
  google.protobuf.Int64Value execution_number = 5;

  // Present if this event is in error, the retry number of this event.
  google.protobuf.Int64Value retry_number = 6;

  reserved 7;
}

// Will trigger at-least-once, and thus events must be idempotent.  After
//   triggering, an event will go to a terminal status, and no longer be an
//   Event object.
message Event {
  // A unique ID assigned to each event, where team name must be the prefix.
  // This is the primary key of the underlying database, so can be used for
  // idempotency purpose.
  google.protobuf.StringValue event_id = 11;

  // event domain, namespace must be prefixed with "team_name" of the
  //   provided API key
  google.protobuf.StringValue namespace = 1;

  // Destination must be mapped to a registered "team_name" of the provided
  //   API key.
  google.protobuf.StringValue destination_id = 2;

  // Custom opaque data understood only be the originaing service.
  //   Max size 2 Kib.
  google.protobuf.StringValue context = 3;

  // Determines the max jitter amount to add to the next start or retry time.
  //   The larger the value, the better. Must be greater than the value
  //   configured by the destination.
  google.protobuf.Duration jitter = 4;

  // How often to retry in case of failure, adjusted by exponential factor
  //   and then a jitter of retry_period/2 is added.
  google.protobuf.Duration retry_period = 5;

  // Specifies exponential backoff.  Must be greater than the value 1.1.
  google.protobuf.FloatValue retry_exponential_factor = 6;

  // When to stop retrying after the trigger_time and mark the event as a
  //   failure
  google.protobuf.Duration retry_duration = 7;

  // Describes how this event will trigger. After an event either
  //   succeeds or errors after the specified retries, the event will move
  //   to a terminal state.  This archived in the EventRun object.
  oneof trigger_mode {
    // Trigger mode where the event will terminate once.
    OneShot one_shot = 8;
    // Trigger mode where the event will reschedule a subsequent event
    //   after the current event terminates.
    Recurring recurring = 9;
  }

  // Optional: Only specify this when directed by the Async Platform team
  EventStrategy event_strategy = 12;

  // Reserved as an output parameter. This field is ignored on input. On input,
  //   this field should be null.
  EventSystemInfo event_system_info = 10;
}

// Describes a trigger_mode where the event will fire once after the
//   trigger_time. More specifically, triggering will be at-least-once, so
//   the events must be idempotent.
message OneShot {
  // The earliest time this event will trigger.  Jitter and other service
  //   calculations may be added to this time. NTP clockdrift may add
  //   or subtract from this time by seconds.  Delays of a couple minutes
  //   should be tolerable.
  google.protobuf.Timestamp trigger_time = 1;
}

// Describes a trigger_mode where the event will schedule a subsequent event
//   specified by a cron string after the current event terminates. Recurring
//   trigger_mode semantics will match Cadence's existing cron semantics:
//   https://cadenceworkflow.io/docs/java-client/distributed-cron/
message Recurring {
  // The cron string (http://cron-parser.com/) for recurring events.
  google.protobuf.StringValue cron = 1;

  // Optional: When this cron schedule starts being valid.
  //   If not present, cron schedule is immediately valid with default now().
  google.protobuf.Timestamp cron_start_time = 2;

  // Optional: When this cron schedule stops being valid.
  //   The valid duration starts at cron_start_time and ends at
  //   cron_start_time + cron_valid_duration.
  //   If not present or 0, cron schedule will stay permanently valid after
  //   becoming valid.  This value cannot be negative.
  google.protobuf.Duration cron_valid_duration = 3;

  // Optional: When specified, the max chain length of events this cron will
  //   create.  If <= 0 or not present, there is no limit to this chain.
  google.protobuf.Int64Value max_executions = 4;
}

// An optional event property that indicates what optimization tradeoffs
//   can be made.
enum StrategyType {
  // The default event. All the APIs provided will work as expected.
  // Note: For now, this is a CRDB implementation.
  STRATEGY_TYPE_UNSPECIFIED = 0;

  // Trade away visibility and editability for more scalability.  There is
  //     NO querying for this event,
  //     NO editing of this event,
  //     and NO deletion of this event.
  // The APIs that perform the above functionality will return as if the event
  //   does NOT EXIST. In addition, idempotency of the event create API no
  //   longer is offerred and uniqueness of eventIds are no longer enforced;
  //   however, it is still good practice to keep eventIds unique to identify
  //   events.
  //
  // Note: For now, this will likely use a Kafka general multi-topic topic
  //   implementation.
  STRATEGY_TYPE_IMMUTABLE = 1;
}

// Allow the specification of a strategy in order to handle this event.
message EventStrategy {
  // Optional: Only specify this when directed by Async Platform team
  StrategyType strategy_type = 1;

  // Optional: Only specify this when directed by Async Platform team
  //   The strategy name must correspond to a pre-allocated resource.
  string strategy_name = 2;
}

// Creates an event.
message CreateEventRequest {
  // Specifies an event.
  Event event = 1;

  reserved 2;
}

// Creating an event returns an unique event_id.
message CreateEventResponse {
  // System info for the event created.
  EventSystemInfo event_system_info = 1;
}

// Updates the trigger time of an existing event.
message UpdateEventTriggerTimeRequest {
  // The same event_id assigned at event creation.
  string event_id = 1;

  // Describes how this event will trigger.
  oneof trigger_mode {
    // Trigger mode where the event will terminate once.
    OneShot one_shot = 2;
    // Trigger mode where the event will reschedule a subsequent event
    //   after the current event terminates.
    Recurring recurring = 3;
  }
}

// Empty placeholder
message UpdateEventTriggerTimeResponse {}

// Returns events that have not terminated and will fire in the future
//   Once an event fires or is no longer valid, the event will no longer
//   exist.  See EventRun
message GetEventRequest {
  // The same event_id assigned at event creation.
  string event_id = 1;
}

// The event response with the corresponding event_id.
//   Once an event fires or is no longer valid, the event will no longer
//   exist.  See EventRun
message GetEventResponse {
  // The event with the corresponding event_id in the request.
  Event event = 1;
}

// Removes an event before it is triggered. An EventRun entry of
//   "EVENT_RUN_STATUS_CANCELED" will be added.
message DeleteEventRequest {
  // The same event_id assigned at event creation.
  string event_id = 1;
}

// Empty placeholder
message DeleteEventResponse {}

// Capability to list events. Prefer GetEvent
message ListEventsRequest {
  // The namespace specified during event creation.
  //   If the namespace is not specified, grpc status `INVALID_ARGUMENT`
  //   will be returned. The API key provided must have access to this
  //   namespace or grpc status `PERMISSION DENIED` will be returned.
  string namespace = 1;

  // Limits results by trigger time. Only events with trigger times
  //   later than this value are returned, exclusive.
  //   If not specified, all results are returned.
  google.protobuf.Timestamp adjusted_trigger_time_begin = 2;

  // Limits results by trigger time. Only events with trigger times
  //   earlier or equal to this value are returned, inclusive.
  //   If not specified, all results are returned.
  google.protobuf.Timestamp adjusted_trigger_time_end = 3;

  // The maximum number of events to return. The service may return fewer than
  // this value.
  // If unspecified, at most 50 events will be returned.
  // The maximum value is 1000; values above 1000 will be coerced to 1000.
  int32 page_size = 4;

  // A page token, received from the previous `ListEvents` call.
  // Provide this to retrieve the subsequent page.
  //
  // When paginating, all other parameters provided to `ListEvents` must match
  // the call that provided the page token.
  // Follows pagination standard here: https://google.aip.dev/158
  string page_token = 5;
}

// events that fit the response criteria.
message ListEventsResponse {
  // events that fit the request criteria
  repeated Event event = 1;

  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  string next_page_token = 2;
}

// Status of the event. Typical event lifecyle is WAIT --> COMPLETED
//   A terminal status is the end of the event lifecycle, and the
//   record is only kept for archive purposes.
enum EventRunStatus {
  // Sentinel status. No intention of using this enum default.
  EVENT_RUN_STATUS_UNSPECIFIED = 0;

  // terminal, success
  EVENT_RUN_STATUS_COMPLETED = 1;

  // terminal, success, last run of a cron
  EVENT_RUN_STATUS_FINALIZED = 2;

  // terminal, event canceled by user via event delete
  EVENT_RUN_STATUS_CANCELED = 3;

  // terminal, expiration happened before run.
  EVENT_RUN_STATUS_EXPIRED = 4;

  // terminal - event is considered an error.  All retries exhausted.
  EVENT_RUN_STATUS_ERROR = 5;

  // not_terminal, event error; but subsequent retry is possible
  EVENT_RUN_STATUS_ERROR_RETRY = 6;
}

// A record of an event run. This is intended to be kept for debuggability,
//   but will only kept around for a few days.
message EventRun {
  // ID uniquely identifying this event run.
  string event_run_id = 1;

  // Original event as specified by the service owner
  Event event = 2;

  // Result status of the event run.
  EventRunStatus event_run_status = 3;

  // Result detail of the event run.
  string event_run_detail = 5;

  // Time the event was actually run.
  google.protobuf.Timestamp actual_trigger_time = 4;
}

// List event runs.  Event runs are held for archival purposes and will
//   be deleted after a short amount of time, likely around a few days.
message ListEventRunsRequest {
  // The namespace specified during event creation.
  //   If the namespace is not specified, grpc status `INVALID_ARGUMENT`
  //   will be returned. The API key provided must have access to this
  //   namespace or grpc status `PERMISSION DENIED` will be returned.
  string namespace = 1;

  // If specified, only EventRuns generated by this eventId are returned. If
  //   this event is a recurring parent event created by the caller (rather
  //   than created from a recurring event), then EventRuns from any children
  //   will also be returned.
  //   If not specified, all EventRuns will be returned.
  google.protobuf.StringValue event_id = 2;

  // If specified, only events with the specified statuses specified will be
  //   returned.
  //   If not specified, all events will be returned.
  repeated EventRunStatus event_run_status = 3;

  // Limits results by trigger time. Only EventRuns with trigger times
  //   later than this value are returned, exclusive.
  //   If not specified, all results are returned.
  google.protobuf.Timestamp adjusted_trigger_time_begin = 4;

  // Limits results by trigger time. Only EventRuns with trigger times
  //   earlier or equal to this value are returned, inclusive.
  //   If not specified, all results are returned.
  google.protobuf.Timestamp adjusted_trigger_time_end = 5;

  // The maximum number of events to return. The service may return fewer than
  //   this value.
  //   If unspecified, at most 50 events will be returned.
  //   The maximum value is 1000; values above 1000 will be coerced to 1000.
  int32 page_size = 6;

  // A page token, received from the previous `ListEventRuns` call.
  //   Provide this to retrieve the subsequent page.
  //   When paginating, all other parameters provided to `ListEventRuns` must
  //   match the call that provided the page token.
  //   Follows pagination standard here: https://google.aip.dev/158
  string page_token = 7;
}

// Event runs are event execution results.
message ListEventRunsResponse {
  // event runs
  repeated EventRun event_runs = 1;

  // A token that can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  string next_page_token = 2;
}
