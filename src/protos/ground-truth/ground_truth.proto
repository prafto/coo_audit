syntax = "proto3";

package doordash.groundtruth.v1;

import "common/service_client_config.proto";
import "doordash.api/annotations.proto";
import "fulfillment_gateway/fulfillment_gateway_core.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "google/rpc/status.proto";
import "ground-truth/gt_task_common.proto";

option java_generic_services = true;
option java_multiple_files = true;
option java_package = "com.doordash.rpc.groundtruth.v1";

// The service for ground truth
service GroundTruthService {
  option (doordash.api.service) = {
    name: "ground-truth-web"
    port: 50051
    name_spaces: ["nv_ground_truth"]
    owner: {
      id: "alerts-dashboards-for-nve-ground-tru"
      name: "ground-truth"
      slack_channel: "#inventory-quality"
      email_alias: "inventory-quality@doordash.com"
    }
    target_products: [
      CX,
      DX,
      INTERNAL
    ]
  };

  // Endpoint
  rpc SearchStoreItemsInference(SearchStoreItemsInferenceRequest) returns (SearchStoreItemsInferenceResponse);
  // batch recognition polling
  rpc GetRecognitions(GetRecognitionsRequest) returns (GetRecognitionsResponse);
  // get the availability infromation from the ground-truth
  rpc GetGroundTruthAvailability(GetGroundTruthAvailabilityRequest) returns (GetGroundTruthAvailabilityResponse);
  // Obtain information of shelf tag scanning task
  rpc GetShelfTagScanTask(GetShelfTagScanTaskRequest) returns (GetShelfTagScanTaskResponse);
  // Commit to shelf tag scanning task (opt-in)
  rpc CommitShelfTagScanTask(CommitShelfTagScanTaskRequest) returns (CommitShelfTagScanTaskResponse);
  // Abort shelf tag scanning task (opt-out)
  rpc AbortShelfTagScanTask(AbortShelfTagScanTaskRequest) returns (AbortShelfTagScanTaskResponse);
  // Finish a shelf tag scanning task
  rpc CompleteShelfTagScanTask(CompleteShelfTagScanTaskRequest) returns (CompleteShelfTagScanTaskResponse);
  // Launch a long term oos detection task
  rpc LaunchShelfTagScanLongTermOosDetectionRun(LaunchShelfTagScanLongTermOosDetectionRunRequest) returns (LaunchShelfTagScanLongTermOosDetectionRunResponse);
  // Get status for shelf tag scan task
  rpc GetShelfTagScanLongTermOosDetectionRunStatus(GetShelfTagScanLongTermOosDetectionRunStatusRequest) returns (GetShelfTagScanLongTermOosDetectionRunStatusResponse);
  // Get list of scan tasks for a given store or task id
  rpc GetScanTaskList(GetScanTaskListRequest) returns (GetScanTaskListResponse);
  // JETS endpoint to upload compressed photos
  rpc UploadScanData(UploadScanDataRequest) returns (UploadScanDataResponse);
  // JETS endpoint for creating a Dx Scan task assignment (which wraps a ScanTaskList)
  rpc CreateJetsScanTask(CreateJetsScanTaskRequest) returns (CreateJetsScanTaskResponse);
  // JETS endpoint for creating a Dx Scan task assignment (which wraps a ScanTaskList), updated to support Unified Gateway
  rpc CreateJetsScanTaskV2(CreateJetsScanTaskV2Request) returns (CreateJetsScanTaskV2Response) {
    option (google.api.http) = {
      post: "/nv_ground_truth/v2/inventory/jets/create_jets_scan_task"
      body: "*"
    };

    option (doordash.api.endpoint) = {
      tier: T2
      lifecycle: DEV
      authorization: [DD_EMPLOYEE]
      target_products: [INTERNAL]
    };

    option (service_client.client_method_config).response_attempt_timeout_millis = 5000;
  }
  // Process an INF-P run for a business or store
  rpc ProcessINFP(ProcessINFPRequest) returns (ProcessINFPResponse);
  // Process ST OOS backfill task
  rpc ProcessSTOosBackfillTask(ProcessSTOosBackfillTaskRequest) returns (ProcessSTOosBackfillTaskResponse);
  // Create synthetic ST OOS Signal
  rpc CreateSyntheticStockLevelSignal(CreateSyntheticStockLevelSignalRequest) returns (CreateSyntheticStockLevelSignalResponse);
  // UploadVisualSearchImage
  rpc PerformVisualSearch(PerformVisualSearchRequest) returns (PerformVisualSearchResponse) {
    option (google.api.http) = {
      post: "/nv_ground_truth/v1/perform_visual_search"
      body: "*"
    };

    option (doordash.api.endpoint) = {
      tier: T3
      lifecycle: DEV
      authorization: [CX_USER]
      target_products: [CX]
    };

    option (service_client.client_method_config).response_attempt_timeout_millis = 60000;
  }

  // Run OCR pipeline. Mainly used for testing. The request/response format are purposefully kept generic without
  // types for input/output, so we can use this for different request in sandbox
  rpc TestOcrPipelineRun(TestOcrPipelineRunRequest) returns (TestOcrPipelineRunResponse);

  // Upload images for visual aisles internal tooling
  rpc UploadVisualAislesImages(UploadVisualAislesImagesRequest) returns (UploadVisualAislesImagesResponse) {
    option (google.api.http) = {
      post: "/nv_ground_truth/v1/visual_aisles_internal/upload_image",
      body: "*"
    };
    option (doordash.api.endpoint) = {
      tier: T2
      lifecycle: DEV
      authorization: [DD_EMPLOYEE]
      target_products: [INTERNAL]
    };
  }

  // Read visual aisles and JETS images for visual aisles internal tooling
  rpc GetVisualAislesImages(GetVisualAislesImagesRequest) returns (GetVisualAislesImagesResponse) {
    option (google.api.http) = {get: "/nv_ground_truth/v1/visual_aisles_internal/images"};
    option (doordash.api.endpoint) = {
      tier: T2
      lifecycle: DEV
      authorization: [DD_EMPLOYEE]
      target_products: [INTERNAL]
    };
    option (service_client.client_method_config).response_attempt_timeout_millis = 10000;
  }

  // Create generic Ground Truth Task - Includes Area photos task or any other generic task
  rpc CreateGroundTruthTask(CreateGroundTruthTaskRequest) returns (CreateGroundTruthTaskResponse);

  // Get list of Ground Truth Tasks based on filters
  rpc GetGroundTruthTasks(GetGroundTruthTasksRequest) returns (GetGroundTruthTasksResponse);

  // Create a new store configuration
  rpc CreateStoreConfig(CreateStoreConfigRequest) returns (CreateStoreConfigResponse);

  // Update an existing store configuration
  rpc UpdateStoreConfig(UpdateStoreConfigRequest) returns (UpdateStoreConfigResponse);

  // Get a store configuration by store ID
  rpc GetStoreConfig(GetStoreConfigRequest) returns (GetStoreConfigResponse);

  // Get presigned URLs for uploading scan images
  rpc GetScanUrls(GetScanUrlsRequest) returns (GetScanUrlsResponse) {
    option (google.api.http) = {get: "/nv_ground_truth/v1/inventory/jets/get_scan_urls"};

    option (doordash.api.endpoint) = {
      tier: T2
      lifecycle: DEV
      authorization: [DD_EMPLOYEE]
      target_products: [
        INTERNAL,
        DX
      ]
    };

    option (service_client.client_method_config).response_attempt_timeout_millis = 10000;
  }
}

// Status enum for store configurations
enum StoreConfigStatus {
  // Unspecified status (default)
  STORE_CONFIG_STATUS_UNSPECIFIED = 0;
  // Store config is active
  STORE_CONFIG_STATUS_ACTIVE = 1;
  // Store config is inactive
  STORE_CONFIG_STATUS_INACTIVE = 2;
  // Store config is pending approval
  STORE_CONFIG_STATUS_PENDING = 3;
  // Store config is archived
  STORE_CONFIG_STATUS_ARCHIVED = 4;
  // Store config is in unknown state
  STORE_CONFIG_STATUS_UNKNOWN = 5;
}

// Store configuration model
message StoreConfig {
  // Unique identifier for the store
  string store_id = 1;
  // Name of the merchant
  string merchant_name = 2;
  // Business ID associated with the store
  string business_id = 3;
  // JSON string containing store-specific overrides
  string store_overrides = 4;
  // Status of the store configuration
  StoreConfigStatus status = 5;
  // Schema version for this configuration
  int32 schema_version = 6;
  // Timestamp when the store was launched
  google.protobuf.Timestamp launched_at = 7;
  // Timestamp when the config was created
  google.protobuf.Timestamp created_at = 8;
  // Timestamp when the config was last updated
  google.protobuf.Timestamp updated_at = 9;
  // User who last updated the config
  string updated_by = 10;
}

// Request for creating a new store configuration
message CreateStoreConfigRequest {
  // Unique identifier for the store (required)
  string store_id = 1;
  // Name of the merchant
  string merchant_name = 2;
  // Business ID associated with the store (required)
  string business_id = 3;
  // JSON string containing store-specific overrides
  string store_overrides = 4;
  // Status of the store configuration (defaults to ACTIVE if not specified)
  StoreConfigStatus status = 5;
  // Schema version for this configuration (optional)
  google.protobuf.Int32Value schema_version = 6;
  // Timestamp when the store was launched (optional)
  google.protobuf.Timestamp launched_at = 7;
}

// Response for creating a store configuration
message CreateStoreConfigResponse {
  // The created store configuration
  StoreConfig store_config = 1;
}

// Request for updating an existing store configuration
message UpdateStoreConfigRequest {
  // Unique identifier for the store (required)
  string store_id = 1;
  // Name of the merchant (optional)
  google.protobuf.StringValue merchant_name = 2;
  // Business ID associated with the store (optional)
  google.protobuf.StringValue business_id = 3;
  // JSON string containing store-specific overrides (optional)
  google.protobuf.StringValue store_overrides = 4;
  // Status of the store configuration (optional)
  StoreConfigStatus status = 5;
  // Schema version for this configuration (optional)
  google.protobuf.Int32Value schema_version = 6;
  // Timestamp when the store was launched (optional)
  google.protobuf.Timestamp launched_at = 7;
  // User who is making the update (required)
  string updated_by = 8;
}

// Response for updating a store configuration
message UpdateStoreConfigResponse {
  // The updated store configuration
  StoreConfig store_config = 1;
}

// Request for retrieving a store configuration
message GetStoreConfigRequest {
  // Unique identifier for the store
  string store_id = 1;
}

// Response for retrieving a store configuration
message GetStoreConfigResponse {
  // The store configuration or null if not found
  StoreConfig store_config = 1;
}

// Request object for TestOcrPipelineRun endpoint. The schema is purpose
message TestOcrPipelineRunRequest {
  // request id. if request id supplied, will return result of the existing run associated with the id
  // else, will generated a new ocr detection run, and an associated request id
  google.protobuf.StringValue request_id = 1;
  // request payload in json format
  google.protobuf.StringValue request_payload = 2;
}

// Response object for TestOcrPipelineRun endpoint
message TestOcrPipelineRunResponse {
  // request id. will always be present
  google.protobuf.StringValue request_id = 1;
  // rpc status code
  google.rpc.Status status = 2;
  // response message (detail about execution)
  google.protobuf.StringValue message = 3;
  // response payload (result of execution)
  google.protobuf.StringValue response_payload = 4;
}

// Request object for create synthetic data endpoint
message CreateSyntheticStockLevelSignalRequest {
  // request id. if request id supplied, will return result of the existing run associated with the id
  // else, will generated a new ocr detection run, and an associated request id
  google.protobuf.StringValue request_id = 1;
  // request payload in json format
  google.protobuf.StringValue request_payload = 2;
}

// Response object for create synthetic data endpoint
message CreateSyntheticStockLevelSignalResponse {
  // request id. will always be present
  google.protobuf.StringValue request_id = 1;
  // response result
  google.protobuf.StringValue response = 2;
  // rpc status code
  google.rpc.Status status = 3;
}

// Request object for ProcessSTOosBackfillTask endpoint
message ProcessSTOosBackfillTaskRequest {
  // request payload in json format
  google.protobuf.StringValue request_payload = 1;
  // request id
  google.protobuf.StringValue request_id = 2;
  // status for the back fill request
  enum BackFillStatus {
    // Unspecified
    BACK_FILL_STATUS_UNSPECIFIED = 0;
    // Success
    BACK_FILL_STATUS_PENDING = 1;
    // Invalid request
    BACK_FILL_STATUS_INVALID_REQUEST = 2;
    // Failed
    BACK_FILL_STATUS_FAILED = 3;
    // Success
    BACK_FILL_STATUS_SUCCESS = 4;
  }
  // status of the backfill task
  BackFillStatus status = 3;
}

// Response object for ProcessSTOosBackfillTask endpoint
message ProcessSTOosBackfillTaskResponse {
  // Request id as supplied by original request or by server (if not supplied)
  google.protobuf.StringValue request_id = 1;
}

// Request object for LaunchShelfTagScanLongTermOosDetectionRun endpoint
message LaunchShelfTagScanLongTermOosDetectionRunRequest {
  // force a new task to be created even if task already exists
  google.protobuf.BoolValue force_run = 1;
  // config for task
  google.protobuf.StringValue long_term_oos_detector_config = 2;
}

// Response object for LaunchShelfTagScanLongTermOosDetectionRun endpoint
message LaunchShelfTagScanLongTermOosDetectionRunResponse {
  // request id
  google.protobuf.StringValue request_id = 1;
  // response result
  google.protobuf.StringValue response = 2;
  // detection task execution status
  ShelfTagScanDetectionTaskStatus task_status = 3;
}

// Request object for GetShelfTagScanLongTermOosDetectionRunStatus endpoint to get task completion status
message GetShelfTagScanLongTermOosDetectionRunStatusRequest {
  // request id
  google.protobuf.StringValue request_id = 1;
}

// Response object for GetShelfTagScanLongTermOosDetectionRunStatus endpoint to get task completion status
message GetShelfTagScanLongTermOosDetectionRunStatusResponse {
  // request id
  google.protobuf.StringValue request_id = 1;
  // response result
  google.protobuf.StringValue response = 2;
  // detection task execution status
  ShelfTagScanDetectionTaskStatus task_status = 3;
}

// Enum to capture the possible shelf tag scan task status
enum ShelfTagScanDetectionTaskStatus {
  // Unspecified
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_UNSPECIFIED = 0;

  // Task completes successfully
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_DONE = 1;

  // Task failed
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_FAILED = 2;

  // Task not yet finished
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_PENDING = 3;

  // Task is duplicate
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_DUPLICATE = 4;

  // Task failed due to endpoint related issue, not with execution
  SHELF_TAG_SCAN_DETECTION_TASK_STATUS_FAILED_INTERNAL = 5;
}

// Request object for the SearchStoreItemsInference endpoint
message SearchStoreItemsInferenceRequest {
  // Either upc or item_name have to be supplied for searching purpose
  oneof search_key {
    // (Optional) upc of item for searching
    string upc = 1;
    // (Optional) name of item for searching
    string item_name = 2;
  }
  // (Optional) Confidence level for searching
  double confidence_level = 3;

  // (Optional) store id for searching
  string store_id = 4;

  // (Optional) number of data records per page
  int32 per_page = 5;

  // (Optional) page number for results
  int32 page_number = 6;

  // (Optional) last returned iguazu uuid (for faster search of next page results)
  string last_returned_iguazu_uuid = 7;
}

// Response object for the SearchStoreItemsInference endpoint
message SearchStoreItemsInferenceResponse {
  // List of item inference data that matches search criteria
  repeated ItemInferenceData items_inference_list = 1;
}

// Request Object for GetRecognitions end point
message GetRecognitionsRequest {
  // required list of image UUIDs. The id is of the iguazu message that
  // was sent with the image details including the image url. The iguazu
  // UUID itself is treated as the image id.
  repeated string image_uuids = 1;
}

// Response Object for GetRecognitions end point
message GetRecognitionsResponse {
  // List of recognitions for each of the image UUIDs that was provided
  // in the request.
  repeated ImageRecognition image_recognitions = 1;
}

// Request object for the availability
message GetGroundTruthAvailabilityRequest {
  // the request id to track the request
  string request_id = 1;
  // the customer for which the information is being pulled
  // this is required to conduct consumer A/B testing
  Consumer consumer = 2;
  // The store for which the items need to be pulled information for
  string store_id = 3;
  // The list of merchant supplied item ids for which the information should be pulled
  repeated string merchant_supplied_item_id = 4;
}

// Consumer object
message Consumer {
  // id for the DD consumer
  int64 id = 1;
  // flag to specifiy if the user is an employee
  bool is_employee = 2;
}

// GT availability response
message GetGroundTruthAvailabilityResponse {
  // item with the availability details
  repeated GroundTruthAvailabilityFacts ground_truth_item = 1;
}

// Item inference data object
message ItemInferenceData {
  // ID of the store photo taken for
  string store_id = 1;

  // Image url uploaded
  string image_url = 2;

  // UPC of the recognized product
  string upc = 3;

  // Name of the item
  string item_name = 4;

  // The confidence fraction with which the product was identified.
  // Score above 0.65 would mean we are fairly confident of recognition.
  double confidence_score = 5;

  // Timestamp when the photo was taken
  google.protobuf.Timestamp photo_timestamp = 6;

  // Timestamp of photo inference
  google.protobuf.Timestamp inference_timestamp = 7;

  // Bounding box of the current identified product on the original image
  BoundingBox bounding_box = 8;

  // (Future compatibility) Barcode to represent an item
  // Currently used as the identifier for the universal product catalog.
  string gtin_14 = 9;

  // Iguazu uuid (unique id) for pagination purpose
  string iguazu_uuid = 10;
}

// Barcode scanned shelf photo details
message BarcodeScannedShelfPhoto {
  // ID of the store photo taken for
  string store_id = 1;

  // Timestamp when the photo was taken
  google.protobuf.Timestamp photo_timestamp = 2;

  // Image url uploaded
  string image_url = 3;

  // JSON encoded metadata describing the contents of the image
  string metadata = 4;

  // Photos of barcodes (taken as the client scans barcodes)
  google.protobuf.StringValue barcode_photo_urls = 5;

  // Dasher Id
  string dasher_id = 6;

  // Dataset this image is associated with (set from the client)
  string dataset_id = 7;
}

// Store photo details
message StoreItemPhoto {
  // ID of the store photo taken for
  string store_id = 1;

  // Delivery uuid photo taken for
  string delivery_uuid = 2;

  // Skus identified in the photo
  repeated string skus_identified = 3;

  // Timestamp when the photo was taken
  google.protobuf.Timestamp photo_timestamp = 4;

  // Image url uploaded
  string image_url = 5;

  // Dasher Id
  string dasher_id = 6;

  // Barcodes of items scanned
  google.protobuf.StringValue barcode_scans = 7;

  // Item id
  string item_id = 8;

  // business id of the store that the photo is taken for
  string business_id = 9;

  // record JSON metadata sent from client
  string metadata = 10;
}

// Photo Inference Data. Involve tech-realtime for backward incompatible changes
// as it could affect publishing to Snowflake
message StoreItemPhotoInference {
  // unique identifier for this inference message
  string event_uuid = 1;

  // unique identifier for the original photo capture event
  string photo_capture_iguazu_event_uuid = 2;

  // Structure to contain the co-ordinated of identified product in the image
  message BoundingBox {
    // Left co-ordinate of the bounding box
    int32 left = 1;

    // Top co-ordinate of the bounding box
    int32 top = 2;

    // Right co-ordinate of the bounding box
    int32 right = 3;

    // Bottom co-ordinate of the bounding box
    int32 bottom = 4;
  }

  // bounding box of the current identified product on the original image
  BoundingBox bounding_box = 3;

  // item id of the identified product from the menu
  string menu_item_id = 4;

  // the confidence fraction with which the product was identified. score
  // above 0.65 would mean we are fairly confident of recognition
  double confidence_score = 5;

  // Category of the product identified. This would also be fetched from menu
  string category = 6;

  // Additional metadata for the inference. This could include the model infromation
  // that was used for the product detection
  map<string, string> metadata = 7;

  // Enum to capture the possible sources of inference.
  enum InferenceSource {
    // Error scenario, image reconition result from unknown source
    INFERENCE_SOURCE_UNSPECIFIED = 0;

    // image recognition result source from 3P Bossa Nova
    INFERENCE_SOURCE_BOSSA_NOVA = 1;

    // image recognition result source from 1P i.e DOORDASH
    INFERENCE_SOURCE_DOORDASH = 2;
  }

  // provides the source of the image recognition
  InferenceSource inference_source = 8;

  // The UPC of the recognized product provided by the inference source
  string inference_provided_upc = 9;

  // Timestamp when the inference was drawn
  google.protobuf.Timestamp inference_timestamp = 10;

  // The name of the identified product provided by the inference source
  string inference_provided_product_name = 11;

  // The stage from where the inference is published. LOCAL/STAGING/PROD
  string stage = 12;

  // the merchant supplied item ids retrieved from Catalog with UPC normalization
  repeated string merchant_supplied_item_ids = 13;

  // Structure to contain nearest neighbor match information
  message NearestNeighbor {
    // The UPC of the recognized product provided by the inference source
    string inference_provided_upc = 1;

    // the confidence fraction with which the product was identified. score
    // above 0.65 would mean we are fairly confident of recognition
    double confidence_score = 2;

    // The name of the identified product provided by the inference source
    string inference_provided_product_name = 3;

    // the merchant supplied item ids retrieved from Catalog with UPC normalization
    repeated string merchant_supplied_item_ids = 4;

    // Confidence score ranging from 0 to 1, indicating how likely this inference's L1 category is correct.
    // This value is derived by weighting the categories in the image by the confidences of the inferences they're
    // associated with.
    //
    // It's expected that this will be used upstream to filter out inferences that are likely to be wrong given the
    // overall context of the image.
    //
    // If the inference is associated with more than one L1 category, the largest value between the categories is
    // chosen.
    double l1_category_confidence_score = 5;
  }

  // Next best matches for the product
  repeated NearestNeighbor nearest_neighbors = 14;

  // Confidence score ranging from 0 to 1, indicating how likely this inference's L1 category is correct.
  // This value is derived by weighting the categories in the image by the confidences of the inferences they're
  // associated with.
  //
  // It's expected that this will be used upstream to filter out inferences that are likely to be wrong given the
  // overall context of the image.
  //
  // If the inference is associated with more than one L1 category, the largest value between the categories is
  // chosen.
  double l1_category_confidence_score = 15;

  // URL of the photo this inference is associated with.
  //
  // Normally we'd just join this store_item_photo table to collect this information, however a bug in our clients
  // has thwarted our ability to do this join using the information in the photo_capture_iguazu_event_uuid field.
  // To work around this, and prevent the need for future backfills should this happen again, we are just collecting
  // the photo URL information per inference directly.
  //
  // This does have the caveat that inference information could be duplicated if we ever re-run our image processing
  // workflows, or if the client sends up the same URL in telemetry events multiple times.  But our queries can
  // handle this pretty easily assuming the bounding boxes or inferred UPCs for the inferences don't change between
  // duplicated events, allowing us to just choose whatever the latest inference is.
  string photo_url = 16;

  // Confidence score ranging from 0 to 1, indicating the likelyhood that this item was observed at this location in
  // the past.  The value is derived by identifying landmark items in the image, and looking back over past photos
  // to find similar configurations of these landmarks.  This confidence score increases as more landmarks are found
  // in common between this image and a past image.
  double location_confidence_score = 17;

  // URL of the photo capturing the previously observed location of the inference.
  //
  // This is mainly intended to be used for debugging purposes, so that we can easily visualize previous photos
  // capturing this location.
  string location_photo_url = 18;

  // Enum to capture the type of inference
  enum InferenceType {
    // Linter forced enum definition.  If this is observed, this will be associated with positive inferences that
    // were published using an older version of this model.
    INFERENCE_TYPE_UNSPECIFIED = 0;

    // This is an inference indicating that an item is recognized as present in the image.
    INFERENCE_TYPE_POSITIVE = 1;

    // This is an inference indicating that an item is recognized as missing in the image.
    INFERENCE_TYPE_NEGATIVE = 2;
  }

  // provides the type of inference being made with this entry.
  InferenceType inference_type = 19;
}

// Store item enrollment details
message StoreItemEnrollment {
  // ID of the store photo taken for
  string store_id = 1;

  // Timestamp when the photo was taken
  google.protobuf.Timestamp photo_timestamp = 2;

  // Image urls uploaded. This could be a list of 3 to 10 images
  // instead of 'repeated' keeping it as nullable string as the
  // client common telemetry library squashes arrays to string
  string image_urls = 3;

  // barcode scan would contain the upc of the product
  // being enrolled
  string barcode_scan = 4;

  // user type to denote the type of the user for the user_id
  // field. This is kept as string because of complexity in
  // addition of a new value in the enum. This type could be
  // : DASHER
  // : SHOPPER
  // : OPERATOR
  // : CONSUMER
  string user_type = 5;

  // user id for the person who took the images
  string user_id = 6;
}

// Tracks events when Dx shop in store
// RFC: https://docs.google.com/document/d/1GQfCqWBXh_MwR3R042YfJusX3ghZ4FSpzcnFkL0TQfc/edit?usp=sharing
message DasherInStoreEvent {
  // Delivery uuid
  string delivery_id = 1;
  // Timestamp when the event happens
  google.protobuf.Timestamp event_timestamp = 2;
  // Event type
  EventType event_type = 3;
  // Store id
  string store_id = 4;
  // Dasher id
  string dasher_id = 5;
  // Merchant supplied item id
  string merchant_supplied_item_id = 6;
  // Picture uuid to map to GT pictures taken by Dx
  string picture_uuid = 7;
  // Represent Oriient location data when the event happens
  OriientData oriient_data = 8;
}

// Type of the event
enum EventType {
  // unsupported event type
  EVENT_TYPE_UNSPECIFIED = 0;
  // start shopping
  EVENT_TYPE_START_SHOPPING = 1;
  // end shopping
  EVENT_TYPE_END_SHOPPING = 2;
  // start calibration
  EVENT_TYPE_START_CALIBRATION = 3;
  // end calibration
  EVENT_TYPE_END_CALIBRATION = 4;
  // scan barcode
  EVENT_TYPE_SCAN_BARCODE = 5;
  // take picture
  EVENT_TYPE_TAKE_PICTURE = 6;
}

// Oriient data to uniquely identifies a point in Oriient map
message OriientData {
  // X coordinate of the location
  double location_x = 1;
  // Y coordinate of the location
  double location_y = 2;
}

// Structure to contain the co-ordinated of identified product in the image
message BoundingBox {
  // Left co-ordinate of the bounding box
  int32 left = 1;

  // Top co-ordinate of the bounding box
  int32 top = 2;

  // Right co-ordinate of the bounding box
  int32 right = 3;

  // Bottom co-ordinate of the bounding box
  int32 bottom = 4;
}

// Tracks the Availability event from the ground truth observations
// https://docs.google.com/document/d/1vsGLlDe9e7CUIYjR4vnt-6LYYa3eIQBCnCipPZI0VXs/edit
message GroundTruthAvailabilityFacts {
  // requestId to aggregate the GT facts across a run
  // either triggered through RIS call or through cron or
  // real time feature update
  google.protobuf.StringValue request_id = 1;

  // store id for the item
  int64 store_id = 2;

  // merchant supplied item id of the item. The current identifier in retail being used
  // to identify an item
  string merchant_supplied_item_id = 3;

  // Availability as observed by ground truth
  enum Availability {
    // Error scenario
    AVAILABILITY_UNSPECIFIED = 0;
    // OUT_OF_STOCK
    AVAILABILITY_OUT_OF_STOCK = 1;
    // LOW_IN_STOCK
    AVAILABILITY_LOW_IN_STOCK = 2;
    // REGULAR_IN_STOCK
    AVAILABILITY_REGULAR_IN_STOCK = 3;
    // HIGH_IN_STOCK
    AVAILABILITY_HIGH_IN_STOCK = 4;
    // HOLD_OUT_SET
    AVAILABILITY_HOLD_OUT_SET = 5;
  }

  // observed availability of the item
  Availability availability = 4;

  // The raw data, OOS probability score as fetched from OOS model
  google.protobuf.DoubleValue probability = 5;

  // the modelId using which the facts were generated
  google.protobuf.StringValue model_id = 6;

  // The original source of the fact
  enum Source {
    // Error case
    SOURCE_UNSPECIFIED = 0;
    // The availability as predicted by the OOS model
    SOURCE_OOS_CLASSIFIER = 1;
    // The availability provided the merchant
    SOURCE_MERCHANT = 2;
    // The availability scraped from merchant website
    SOURCE_WEB_SCRAPER = 3;
    // The availability as informed by the dasher
    SOURCE_DASHER = 4;
    // The availability as informed by the operator
    SOURCE_OPERATOR = 5;
    // The availability as informed by the shelf tag scan
    SOURCE_SHELF_TAG_SCAN = 6;
    // The availability as informed by the shelf tag scan long term oos detector
    SOURCE_SHELF_TAG_SCAN_LONG_TERM_OOS = 7;
    // The availability as informed by the shelf tag scan short term oos detector
    SOURCE_SHELF_TAG_SCAN_SHORT_TERM_OOS = 8;
  }

  // The source of the item availability
  Source source = 7;

  // This is to measure the delay between the original event
  // and generating the ground truth fact.
  google.protobuf.Timestamp origin_event_time = 8;

  // When the downstream systems were updated
  google.protobuf.Timestamp updated_at = 9;

  // The experiment name for this availability. There could be
  // multiple availabilty for the same item based on the experiments
  // being carried out. This is to support Cx a/b testing of the
  // models and thresholds
  google.protobuf.StringValue experiment = 10;

  // The availability could vary through out the day. start_at field
  // indicates the start time of this view of availability
  google.protobuf.Timestamp start_at = 11;

  // The availability could vary through out the day. expire_at field
  // indicates the end time of this view of availability
  google.protobuf.Timestamp expire_at = 12;
}

// Image Recognition. It contains the status of recognition request
// as well as the result. The recognition result is expected to be
// present only when the status is success.
message ImageRecognition {
  // image UUID would be part of the response to enable any validation
  // based on image id
  string image_uuid = 1;

  // Enum for recognition status
  enum RecognitionStatus {
    // Error Scenario
    RECOGNITION_STATUS_UNSPECIFIED = 0;
    // In Progress
    RECOGNITION_STATUS_IN_PROGRESS = 1;
    // FAILED
    RECOGNITION_STATUS_FAILED = 2;
    // SUCCESS
    RECOGNITION_STATUS_SUCCESS = 3;
  }

  // The status of the image recognition
  RecognitionStatus recognition_status = 2;

  // Each identified bounding box and recognized item if any
  message ItemInference {
    // The unique identifier for the given bounding box
    string inference_id = 1;

    // The bounding box of the identification
    BoundingBox bounding_box = 2;

    // Optional UPC if we were able to recognize the item
    google.protobuf.StringValue inference_provided_upc = 3;

    // Optional Name of the product
    google.protobuf.StringValue inference_provided_product_name = 4;

    // the timestamp when the item was recognized. This is for analytics
    google.protobuf.Timestamp inference_timestamp = 5;
  }

  // List of all the inferences found on the image.
  repeated ItemInference item_inferences = 3;
}

// Request for storing merchant's per store inventory data (boh, last sold date)
message MerchantInventoryUpdateMessage {
  // merchant's name, e.g. Walgreens
  string merchant_name = 1;

  // external merchant's store location id
  string store_id = 2;

  // internal doordash's store id
  string dd_store_id = 3;

  // merchant supplied item id or the external identifier
  // for intance for walgreens it can be article id
  string merchant_item_id = 4;

  // optional, balance on hand for an item (provided by merchant).
  google.protobuf.Int32Value boh = 5;

  // optional, last sold time for an item (provided by merchant)
  google.protobuf.Int64Value last_sold_date_ms = 6;

  // optional, last update time for an item (provided by merchant)
  google.protobuf.Int64Value update_time_ms = 7;

  // process time (provided by doordash system). this more generic name is preferred over iguazu's
  // iguazu_sent_at field become data could also come from ETL job.
  int64 process_time_ms = 8;

  // source of the data (e.g. Merchant API, Nexla)
  string origin = 9;

  // doordash item identifier. for instance for walgreens it
  // can be wic id
  google.protobuf.StringValue dd_item_id = 10;
}

// Status of merchant's store processing
message MerchantStoreApiProcessStatus {
  // store id of the store
  int64 store_id = 1;

  // external merchant's store location id
  string external_store_id = 2;

  // business id of the store
  int64 business_id = 3;

  // total item count for the store
  int64 total_item_count = 4;

  // catalog mis match count for the store
  int64 internal_id_unavailable_count = 5;

  // item count with boh as 0
  int64 boh_0_count = 6;

  // When the inventory was last fetched
  google.protobuf.Timestamp processed_at = 7;

  // Enum for Processing status
  enum Status {
    // Error Scenario
    STATUS_UNSPECIFIED = 0;
    // FAILED because of error in api
    STATUS_FAILED_API = 1;
    // FAILED because of unable to fetch catalog
    STATUS_FAILED_CATALOG = 2;
    // SUCCESS
    STATUS_SUCCESS = 3;
  }

  // processing status
  Status status = 8;
}

// Request object for GetShelfTagScanTask endpoint
message GetShelfTagScanTaskRequest {
  // dd_store_id for the store where the task takes place
  string dd_store_id = 1;
  // business_id for the store where the task takes place
  string business_id = 2;
  // delivery id, unique for each dasher and delivery. can be used as fingerprint for task
  string delivery_id = 3;
}

// Response object for GetShelfTagScanTask endpoint
message GetShelfTagScanTaskResponse {
  // Indicates if task assigned to caller for this request
  bool task_assigned = 1;

  // Definition of a aisle task within shelf tag scan task
  // Definition refer to doc: https://docs.google.com/document/d/1xCkwbEO_9gAewvPQREkjAq1qqguptqZmw9UYDJxpHxM/edit
  message AisleTask {
    // Title of aisle task to display
    string title = 1;
    // Message of aisle task to display
    string message = 2;
  }

  // Store configs
  message StoreConfig {
    // List of supported barcode types like ean13, code39, interleaved_2_of_5
    repeated string supported_barcode_types = 1;
    // List of keywords like "Buy", "More", "Save", "Promo", "Now", "Free", "Sale", "Price", "Approved", "Food", "Each"
    repeated string shelf_tag_keywords = 2;
  }

  // Definition of a shelf tag scan task
  message ShelfTagScanTask {
    // List of AisleTasks
    repeated AisleTask aisles = 1;
    // Store config
    StoreConfig store_config = 2;
    // Description of ShelfTagScanTask
    string task_description = 3;
    // Instruction of ShelfTagScanTask
    string task_instructions = 4;
    // In progress banner message of ShelfTagScanTask
    string in_progress_banner_title = 5;
    // Completed banner title of ShelfTagScanTask
    string completed_banner_title = 6;
    // Early exist warning of ShelfTagScanTask
    string early_exit_warning_message = 7;
  }

  // Content of a task
  ShelfTagScanTask shelf_tag_scan_task = 2;

  // Error type
  ErrorType error_type = 3;
}

// Request object for CommitShelfTagScanTask endpoint
message CommitShelfTagScanTaskRequest {
  // dd_store_id for the store where the task takes place
  string dd_store_id = 1;
  // business_id for the store where the task takes place
  string business_id = 2;
  // delivery id, unique for each dasher and delivery. can be used as fingerprint for task
  string delivery_id = 3;
}

// Response object for CommitShelfTagScanTask endpoint
message CommitShelfTagScanTaskResponse {
  // Task is marked committed
  bool committed = 1;
  // ErrorType for failing to mark committed
  ErrorType error = 2;
}

// Request object for AbortShelfTagScanTask endpoint
message AbortShelfTagScanTaskRequest {
  // dd_store_id for the store where the task takes place
  string dd_store_id = 1;
  // business_id for the store where the task takes place
  string business_id = 2;
  // delivery id, unique for each dasher and delivery. can be used as fingerprint for task
  string delivery_id = 3;
}

// Response object for AbortShelfTagScanTask endpoint
message AbortShelfTagScanTaskResponse {
  // Task is marked aborted
  bool aborted = 1;
  // ErrorType for failing to mark aborted
  ErrorType error = 2;
}

// Request object for CompleteShelfTagScanTask endpoint
message CompleteShelfTagScanTaskRequest {
  // dd_store_id for the store where the task takes place
  string dd_store_id = 1;
  // business_id for the store where the task takes place
  string business_id = 2;
  // delivery id, unique for each dasher and delivery. can be used as fingerprint for task
  string delivery_id = 3;
}

// Response object for CompleteShelfTagScanTask endpoint
message CompleteShelfTagScanTaskResponse {
  // Task is marked complete
  bool completed = 1;
  // ErrorType for failing to mark complete
  ErrorType error = 2;
}

// shelf_tag_scan_item_identification_result
message ShelfTagScanItemIdentificationResult {
  // store id
  google.protobuf.StringValue store_id = 1;
  // barcode
  google.protobuf.StringValue barcode = 2;
  // barcode_type
  google.protobuf.StringValue barcode_type = 3;
  // business id
  google.protobuf.StringValue business_id = 4;
  // unique id for the shelf tag item
  google.protobuf.StringValue item_id = 5;
  // original event id
  google.protobuf.StringValue event_id = 6;
  // original event time
  google.protobuf.StringValue event_time = 7;
  // process time
  google.protobuf.StringValue process_time = 8;
  // the item id exists in baseline
  google.protobuf.BoolValue in_baseline = 9;
  // the item id exist in current scan
  google.protobuf.BoolValue in_scan = 10;
  // the item captured in current scan is also found in baseline and in roughly the same area as where the
  // current scan image is taken
  google.protobuf.BoolValue in_coverage = 11;
  // type of data for the item entry
  RunType type = 12;
  // identify the execution session for which the item entry is generated
  google.protobuf.StringValue run_id = 13;
  // action type of the item entry
  ActionType action_type = 14;
  // item metadata
  google.protobuf.StringValue item_metadata = 15;
  // the item is inferred instead of detected
  google.protobuf.BoolValue is_inferred = 16;
  // the item is filtered from action
  google.protobuf.BoolValue is_filtered = 17;
  // item filter details
  google.protobuf.StringValue filter_details = 18;
  // item action is enabled
  google.protobuf.BoolValue action_enabled = 19;
}

// metadata about shelf tag scan related runs such as long term oos detection
message ShelfTagScanRunLog {
  // store id
  google.protobuf.StringValue store_id = 1;
  // identify the execution session for which the item entry is generated. Related to the field of same name in
  // ShelfTagScanItemIdentificationResult
  google.protobuf.StringValue run_id = 2;
  // start time of the run
  google.protobuf.StringValue run_start_time = 3;
  // duration of the run
  google.protobuf.Int64Value run_duration_ms = 4;
  // run type
  RunType run_type = 5;
  // configuration used for the run
  google.protobuf.StringValue run_config = 6;
  // metadata used for the run
  google.protobuf.StringValue run_metadata = 7;
  // completion status for the run
  enum CompletionStatus {
    // run status unspecified
    COMPLETION_STATUS_UNSPECIFIED = 0;
    // run succeeded
    COMPLETION_STATUS_SUCCEEDED = 1;
    // run failed
    COMPLETION_STATUS_FAILED = 2;
    // run cancelled
    COMPLETION_STATUS_CANCELLED = 3;
  }
  // completion status
  CompletionStatus completion_status = 8;
  // who/what ran triggered the run
  google.protobuf.StringValue run_by = 9;
  // additional information related to the run, such as error cause
  google.protobuf.StringValue message = 10;
}

// metadata scanned image. the data here is derived from m_full_shelf_tag_photo. since m_full_shelf_tag_photo store
// all image and shelf tag related data in 2 string field as json format, query time has been reported as slow.
// this event captures some of the important data field and is useful for offline analysis and tracking
// location_detail contains key-value pair of sector id (in integer) and
// object {"num_first_pass": Int, "num_second_pass": Int, "num_unrecognized": Int}. This tells us where approximately
// in the image are the shelf tags at. The sectors are divided into 9 (0, 1...7, 8, representing top left, top middle...
// bottom middle, bottom right). This helps us track down where recognized/unrecognized barcodes are distributed.
message ShelfTagScanImageAnalysisLog {
  // store id
  google.protobuf.StringValue store_id = 1;
  // original iguazu id of the captured image
  google.protobuf.StringValue image_id = 2;
  // start time of the image analysis run
  google.protobuf.StringValue run_start_time = 3;
  // duration of the original image capture
  google.protobuf.Int64Value capture_duration_ms = 4;
  // duration of the original detection
  google.protobuf.Int64Value detect_duration_ms = 5;
  // duration of the original processing
  google.protobuf.Int64Value process_duration_ms = 6;
  // url of the image
  google.protobuf.StringValue image_url = 7;
  // image width
  google.protobuf.Int32Value image_pixel_width = 8;
  // image height
  google.protobuf.Int32Value image_pixel_height = 9;
  // number of shelf tags detected
  google.protobuf.Int32Value num_shelf_tags_detected = 10;
  // number of barcodes detected
  google.protobuf.Int32Value num_barcodes_detected = 11;
  // number of barcodes that's detected and is readable
  google.protobuf.Int32Value num_barcodes_readable = 12;
  // detail about which sector the detected shelf tag lay
  google.protobuf.StringValue location_detail = 13;
}

// item identification result log. used for both positive and negative results
message ItemResolutionResultLog {
  // store id
  google.protobuf.Int64Value store_id = 1;
  // barcode
  google.protobuf.StringValue barcode = 2;
  // barcode_type
  google.protobuf.StringValue barcode_type = 3;
  // business id
  google.protobuf.Int64Value business_id = 4;
  // unique id for the shelf tag item
  google.protobuf.StringValue item_id = 5;
  // number of candidate item_ids. normally should be 1, == 0 or > 1 means anomaly
  google.protobuf.Int32Value num_resolved_item_ids = 6;
  // original event id
  google.protobuf.StringValue event_id = 7;
  // scan run id unique identifier for a run, can be used for dedup
  google.protobuf.StringValue run_id = 8;
  // process time
  google.protobuf.StringValue process_time = 9;
  // metadata related to barcode resolution
  google.protobuf.StringValue resolution_metadata = 10;
  // type of resolution method
  ResolutionType resolution_type = 11;
  // barcode resolution reporting type
  BarcodeResolutionReportingType barcode_resolution_reporting_type = 12;
  // normalized barcode from using com.doordash.barcodeNormalizer library
  google.protobuf.StringValue normalized_barcode = 13;
}

// DEPRECATED in favor of event with more generic name
// item identification failure result log
message ItemResolutionFailureLog {
  // store id
  google.protobuf.StringValue store_id = 1;
  // barcode
  google.protobuf.StringValue barcode = 2;
  // barcode_type
  google.protobuf.StringValue barcode_type = 3;
  // business id
  google.protobuf.StringValue business_id = 4;
  // unique id for the shelf tag item
  google.protobuf.StringValue item_id = 5;
  // original event id
  google.protobuf.StringValue event_id = 6;
  // scan run id unique identifier for a run, can be used for dedup
  google.protobuf.StringValue run_id = 7;
  // process time
  google.protobuf.StringValue process_time = 8;
  // metadata related to barcode resolution
  google.protobuf.StringValue resolution_metadata = 9;
  // type of resolution method
  ResolutionType resolution_type = 10;
}

// observation results such as oos detection from Jets scan images
message JetsObservationFacts {
  // store_id
  google.protobuf.Int64Value store_id = 1;
  // item_id, mainly using merchant supplied item id
  google.protobuf.StringValue item_id = 2;
  // signal event time (e.g. when jets image was taken)
  google.protobuf.Int64Value signal_create_time_ms = 3;
  // type of inference
  JetsInferenceType inference_type = 4;
  // oos/in-stock inference result
  JetsInferenceResult inference_result = 5;
  // confidence level of inference
  google.protobuf.DoubleValue inference_confidence = 6;
  // confidence of item_id resolution
  google.protobuf.DoubleValue item_id_confidence = 7;
  // aisle info
  google.protobuf.StringValue aisle_info = 8;
  // category info
  google.protobuf.StringValue category_info = 9;
  // time since the last scan of the key: store_id + item_id + inference_type
  google.protobuf.Int64Value time_since_last_scan = 10;
  // version of the inference model
  google.protobuf.Int64Value version = 11;
  // tags used to add metadata info and filter for the data
  google.protobuf.StringValue tags = 12;
  // signal event timestamp (e.g. when jets image was taken)
  google.protobuf.Timestamp signal_create_time_stamp = 13;
  // business id
  google.protobuf.StringValue business_id = 14;
  // bmsid as formed by joining business_id and msid
  google.protobuf.StringValue bmsid = 15;
  // timezone. Need to decide format, e.g. +/-HH:MM or +/-HHMM
  // should allow natural ordering and easy to compare
  google.protobuf.StringValue timezone = 16;
  // observation prefix. Normally it's blank. It's used to build dedup key
  google.protobuf.StringValue observation_prefix = 17;
  // capture start time. the device time for the exact moment that a photo is captured
  google.protobuf.Timestamp capture_start_time = 18;
  // the photo event that captured the image
  google.protobuf.StringValue photo_event_id = 19;
  // model version of the inference model. MAYBE deprecated in favor of version_objects. Discuss with Jets before use
  google.protobuf.StringValue model_version = 20;
  // version objects for jof event
  repeated VersionObject version_objects = 21;
}

// Features for MLP. This data is post processing from Jets Observation
message JetsMlpFeatures {
  // observation prefix. Normally it's blank. It's used to build dedup key
  google.protobuf.StringValue observation_prefix = 1;
  // store_id
  google.protobuf.Int64Value store_id = 2;
  // item_id, mainly using merchant supplied item id
  google.protobuf.StringValue item_id = 3;
  // signal event time (e.g. when jets image was taken)
  google.protobuf.Timestamp signal_create_time_ms = 4;
  // type of inference
  JetsInferenceType inference_type = 5;
  // oos/in-stock inference result
  JetsInferenceResult inference_result = 6;
  // confidence level of inference
  google.protobuf.DoubleValue inference_confidence = 7;
  // signal event timestamp (e.g. when jets image was taken)
  google.protobuf.Timestamp signal_create_time_stamp = 8;
  // business id
  google.protobuf.StringValue business_id = 9;
  // bmsid as formed by joining business_id and msid
  google.protobuf.StringValue bmsid = 10;
  // timezone Need to decide format, e.g. +/-HH:MM or +/-HHMM
  // should allow natural ordering and easy to compare
  google.protobuf.StringValue timezone = 11;
}

// Iguazu event for tracking Jets observations. Can be used to track and query
// single stage or multi stage operations
message JetsOperationTrackingEvent {
  // trace id
  google.protobuf.StringValue trace_id = 1;
  // pipeline name
  google.protobuf.StringValue pipeline_name = 2;
  // operation name
  google.protobuf.StringValue operation_name = 3;
  // operation id
  google.protobuf.StringValue operation_id = 4;
  // parent operation name
  google.protobuf.StringValue parent_operation_name = 5;
  // parent operation id
  google.protobuf.StringValue parent_operation_id = 6;
  // operation start time
  google.protobuf.Timestamp operation_start_time = 7;
  // operation end time
  google.protobuf.Timestamp operation_end_time = 8;
  // operation status
  JetsOperationStatus operation_status = 9;
  // version id
  google.protobuf.Int64Value version_id = 10;
  // metadata string
  google.protobuf.StringValue metadata_string = 11;
  // tracking details for item identification
  JetsTrackingEventItemIdentificationDetails item_identification_details = 12;
  // tracking details for item identification in json format
  google.protobuf.StringValue item_identification_details_json = 13;
  // json string used for debugging. the caller maintain the schema and ensure they are able to parse it.
  // the specific type is usually depending on the type of tracking event, e.g. item_identification. One should not
  // build long term query based on this field, but rather, use it in the moment for debugging
  // Please make sure this json string contains at least a field called "version" to help query different versions
  // The caller of the event should ensure the schema of this json string is maintained and backward compatible
  google.protobuf.StringValue debug_details_json = 14;
  // Tracking even type
  JetsOperationTrackingEventType event_type = 15;
}

// Types of Jets operation tracking event
enum JetsOperationTrackingEventType {
  // jets operation tracking event type unspecified
  JETS_OPERATION_TRACKING_EVENT_TYPE_UNSPECIFIED = 0;
  // jets operation tracking event type for item identification
  JETS_OPERATION_TRACKING_EVENT_TYPE_ITEM_IDENTIFICATION = 1;
}

// Jets operation status
enum JetsOperationStatus {
  // operation status unspecified
  JETS_OPERATION_STATUS_UNSPECIFIED = 0;
  // operation status success
  JETS_OPERATION_STATUS_SUCCESS = 1;
  // operation status failed
  JETS_OPERATION_STATUS_FAILED = 2;
  // operation status cancelled
  JETS_OPERATION_STATUS_CANCELLED = 3;
}

// Jets Item Identification Tracking Details
message JetsTrackingEventItemIdentificationDetails {
  // Session Id. This is Dx task Id
  google.protobuf.StringValue session_id = 1;
  // Event Id. This is the event id for the uploaded image
  google.protobuf.StringValue event_id = 2;
  // Store Id
  google.protobuf.StringValue store_id = 3;
  // Total shelf tags
  google.protobuf.Int32Value total_shelf_tags = 4;
  // Total initial barcodes
  google.protobuf.Int32Value total_initial_barcodes = 5;
  // Total resolved shelf tags
  google.protobuf.Int32Value total_resolved_shelf_tags = 6;
  // Total OOS items
  google.protobuf.Int32Value total_oos_items = 7;
  // Total InStock items
  google.protobuf.Int32Value total_instock_items = 8;
  // Ocr Decode Time in ms
  google.protobuf.Int64Value ocr_detection_time_ms = 9;
  // Planogram Decode Time in ms
  google.protobuf.Int64Value planogram_time_ms = 10;
  // model version MAYBE deprecated in favor of version_objects. Discuss with Jets before use
  google.protobuf.StringValue model_version = 11;
  // version objects for results
  repeated VersionObject version_objects = 12;
  // total number of barcodes that got translated into msid
  google.protobuf.Int32Value total_translated_barcodes = 13;
  // total barcodes post OCR item identification processing
  google.protobuf.Int32Value total_post_ocr_barcodes = 14;
  // domain name. this is the use domain. Similar to the field in JetsProcessedScanImageData
  google.protobuf.StringValue domain_name = 15;
  // name space. this is the specific use case. Similar to the field in JetsProcessedScanImageData
  google.protobuf.StringValue namespace = 16;
  // number of items with OCR text source being shelf tag
  google.protobuf.Int32Value total_ocr_text_source_shelf_tag = 17;
  // number of items with OCR text source being product
  google.protobuf.Int32Value total_ocr_text_source_product = 18;
  // total tag OCR GPU time
  google.protobuf.Int64Value total_tag_ocr_gpu_time_ms = 19;
  // total product OCR GPU time
  google.protobuf.Int64Value total_product_ocr_gpu_time_ms = 20;
  // total item identification time (remote). this measures execution time on remote server, does not include
  // time waiting in request queue
  google.protobuf.Int64Value total_item_identification_execution_time_ms = 21;
  // debug image url
  google.protobuf.StringValue debug_image_url = 22;
  // runtime ms
  google.protobuf.Int64Value runtime_ms = 23;
  // total number of partial shelf tags (partial shelf tags are unlikely to be decoded
  google.protobuf.Int32Value total_partial_shelf_tags = 24;
  // total number of net new info extracted from OCR. If shelf tag doesn't have translated msid (though it could
  // still have barcode from front end) or if shelf tag has msid, but OCR generated different msid
  google.protobuf.Int32Value total_ocr_net_new_identification = 25;
  // business id
  google.protobuf.StringValue business_id = 26;
  // error type to tell if the event is a retake and hard to decode
  google.protobuf.StringValue error_type = 27;
}

// Jets identified tag info
message JetsTagItemIdentificationDetails {
  // domain name
  google.protobuf.StringValue domain_name = 1;
  // namespace
  google.protobuf.StringValue namespace = 2;
  // store id
  google.protobuf.StringValue store_id = 3;
  // item id. this is the unique identifier for the shelf tag item (e.g. MSID)
  google.protobuf.StringValue item_id = 4;
  // signal create time stamp
  google.protobuf.Timestamp signal_create_time_stamp = 5;
  // original event id. Identifies the original image that was processed
  google.protobuf.StringValue event_id = 6;
  // process result id. Identifies the result of a particular processing
  google.protobuf.StringValue process_result_id = 7;
  // session id. Identifies the session of activity (e.g. Dx scan) that created the original image
  google.protobuf.StringValue session_id = 8;
  // data version
  google.protobuf.StringValue data_version = 9;
  // raw tag details json string
  google.protobuf.StringValue raw_tag_details_json = 10;
  // processing source
  google.protobuf.StringValue processing_source = 11;
}

// Message for logging barcode translation analysis
message JetsBarcodeTranslationTrackingEvent {
  // Store ID
  google.protobuf.StringValue store_id = 1;
  // Image ID
  google.protobuf.StringValue image_id = 2;
  // Scan mode
  google.protobuf.StringValue scan_mode = 3;
  // Total number of shelf tags found in image
  google.protobuf.Int32Value total_shelf_tags = 4;
  // Total initial barcodes detected by FE
  google.protobuf.Int32Value total_initial_barcodes = 5;
  // Number of successful MSID resolutions
  google.protobuf.Int32Value msid_resolution_success_count = 6;
  // Number of failed MSID resolutions
  google.protobuf.Int32Value msid_resolution_fail_count = 7;
  // Success rate of MSID resolutions
  google.protobuf.DoubleValue msid_resolution_success_rate = 8;
  // Type of barcode translation
  BarcodeTranslationType barcode_translation_type = 9;
  // Duration of barcode translation in milliseconds
  google.protobuf.Int64Value barcode_translation_duration_ms = 10;
  // List of failed barcode translations
  repeated BarcodeTranslationFailure barcode_translation_failures = 11;
  // Name of the processor class
  google.protobuf.StringValue class_name = 12;
  // Session ID
  google.protobuf.StringValue session_id = 13;
  // Trace ID
  google.protobuf.StringValue trace_id = 14;
  // Event ID
  google.protobuf.StringValue event_id = 15;
  // Scanned Shelf Image URL
  google.protobuf.StringValue image_url = 16;
  // Compressed shelf tags images URL
  google.protobuf.StringValue shelf_tags_images_url = 17;
  // Compressed products images URL
  google.protobuf.StringValue products_images_url = 18;
}

// Message for details of a failed barcode translation
message BarcodeTranslationFailure {
  // The raw barcode that failed to translate
  google.protobuf.StringValue barcode = 1;
  // The type of the failed barcode
  google.protobuf.StringValue barcode_type = 2;
  // The reason for the failure
  google.protobuf.StringValue failure_reason = 3;
}

// Enum for different types of barcode translation strategies
enum BarcodeTranslationType {
  // Unspecified translation type, used as a default placeholder
  BARCODE_TRANSLATION_TYPE_UNSPECIFIED = 0;
  // Translation method that processes barcodes based on predefined rules and mappings
  BARCODE_TRANSLATION_TYPE_DEFAULT = 1;
  // Translation method with self-loading capabilities, dynamically loading catalog mappings (GTIN to MSID)
  BARCODE_TRANSLATION_TYPE_LOADING = 2;
  // Translation method used primarily for testing and development, not intended for production use
  BARCODE_TRANSLATION_TYPE_MOCK = 3;
}

// Raw tag details
message RawTagDetails {
  // source
  google.protobuf.StringValue source = 1;
  // ocr text
  google.protobuf.StringValue ocr_text = 2;
  // price. detected from ocr. will be in cents. So $5.99 will be 599
  google.protobuf.Int64Value ocr_price_unit_amount_cents = 3;
  // list of image metadata
  repeated ImageMetadata image_metadatas = 4;
  // tag id
  google.protobuf.StringValue tag_id = 5;
}

// types of Jets inference
enum JetsInferenceType {
  // jets inference type unspecified
  JETS_INFERENCE_TYPE_UNSPECIFIED = 0;
  // jets inference type for scan hole (aka short term oos detection)
  JETS_INFERENCE_TYPE_SCAN_HOLE = 1;
  // jets inference type for scan delta (aka long term oos detection)
  JETS_INFERENCE_TYPE_SCAN_DELTA = 2;
}

// types of Jets inference result
enum JetsInferenceResult {
  // jets inference result unspecified
  JETS_INFERENCE_RESULT_UNSPECIFIED = 0;
  // jets inference result for ST OOS
  JETS_INFERENCE_RESULT_SCAN_HOLE_OOS = 1;
  // jets inference result for ST In Stock
  JETS_INFERENCE_RESULT_SCAN_HOLE_IN_STOCK = 2;
  // jets inference result for LT OOS
  JETS_INFERENCE_RESULT_SCAN_DELTA_OOS = 3;
  // jets inference result for LT In Stock
  JETS_INFERENCE_RESULT_SCAN_DELTA_IN_STOCK = 4;
}

// type of resolution method
enum ResolutionType {
  // item resolution type unspecified
  RESOLUTION_TYPE_UNSPECIFIED = 0;
  // item resolution type using barcode
  RESOLUTION_TYPE_BARCODE = 1;
}

// barcode resolution reporting type
enum BarcodeResolutionReportingType {
  // barcode resolution reporting type unspecified
  BARCODE_RESOLUTION_REPORTING_TYPE_UNSPECIFIED = 0;
  // barcode resolution reporting type to report all
  BARCODE_RESOLUTION_REPORTING_TYPE_ALL = 1;
  // barcode resolution reporting type to report only failures
  BARCODE_RESOLUTION_REPORTING_TYPE_ERROR_ONLY = 2;
}

// type of data for the item entry, could be for oos detection or barcode processing
enum RunType {
  // long term oos detection using unspecified method
  RUN_TYPE_OOS_DETECTION_UNSPECIFIED = 0;
  // long term oos detection using linear scan
  RUN_TYPE_OOS_DETECTION_LINEAR_SCAN = 1;
  // long term oos detection using image search
  RUN_TYPE_OOS_DETECTION_IMAGE_LOCATION = 2;
  // long term oos detection using image search with localization of baseline data
  RUN_TYPE_OOS_DETECTION_BOUNDED_IMAGE_LOCATION = 3;
  // bar code resolution prior to long term oos detection
  RUN_TYPE_OOS_BARCODE_RESOLUTION = 4;
}

// type of action taken on the shelf tag item
enum ActionType {
  // action type unspecified
  ACTION_TYPE_UNSPECIFIED = 0;
  // deactivated
  ACTION_TYPE_DEACTIVATED = 1;
  // activated
  ACTION_TYPE_ACTIVATED = 2;
  // should deactivate but didn't (e.g. due to compliance issue)
  ACTION_TYPE_SHOULD_DEACTIVATE = 3;
  // should activate but didn't (e.g. due to compliance issue)
  ACTION_TYPE_SHOULD_ACTIVATE = 4;
  // skipped due to compliance issue
  ACTION_TYPE_SKIPPED = 5;
  // already activated
  ACTION_TYPE_ALREADY_ACTIVATED = 6;
  // already deactivated
  ACTION_TYPE_ALREADY_DEACTIVATED = 7;
}

// Type of error when managing task
enum ErrorType {
  // Unspecified error type
  ERROR_TYPE_NOT_FOUND_UNSPECIFIED = 0;
  // Task isn't found for current fingerprint
  ERROR_TYPE_NOT_FOUND = 1;
  // Internal error managing task on server side
  ERROR_TYPE_INTERNAL = 2;
}

// GetScanTaskListRequest object
message GetScanTaskListRequest {
  // id of store (for debug/ops mode)
  google.protobuf.StringValue store_id = 1;
  // id of shelf scan task
  google.protobuf.StringValue task_id = 2;
}

// GetScanTaskListResponse Object
message GetScanTaskListResponse {
  reserved 3;
  reserved "aisle_tasks";

  // Store configs
  message StoreConfig {
    // List of supported barcode types like ean13, code39, interleaved_2_of_5
    repeated string supported_barcode_types = 1;
    // Link to merchant approval document if dashers are asked to present it
    google.protobuf.StringValue mx_approval_document_url = 2;
    // If the store doesn't have any aisle data, we can set this field to true to collect simple aisle data (number of aisles, walls, etc.)
    google.protobuf.BoolValue should_collect_simple_aisle_info = 3;
    // Store ID
    string store_id = 4;
    // Default value if a scan task doesn't override
    double default_min_shelf_tag_detection_rate_per_photo = 5;
  }

  // Store config
  StoreConfig store_config = 1;

  // TaskConfig for GetScanTasksList
  message TaskConfig {
    // Task ID
    string task_id = 1;

    // Data for a FAQ card in the FAQ Carousel
    message FAQContent {
      // Title of the card
      string title = 1;
      // Message/content of the card
      string message = 2;
    }

    // List of faq contents to build a carousel in the front-end
    repeated FAQContent faq_content = 2;
  }

  // Task config
  TaskConfig task_config = 2;

  // ScanTask for GetScanTasksList
  message ScanTask {
    reserved 1, 2, 9;
    reserved "aisle_id", "aisle_name", "min_shelf_tag_detection_rate_per_photo";

    // How many items we're expecting to scan, to help calculate current progress during scan task
    google.protobuf.Int32Value expected_unique_items = 3;
    // How much of the expected items we need to scan to consider the task completed
    google.protobuf.DoubleValue expected_coverage_percentage = 4;
    // Text instructions to accompany the task
    string subtitle = 5;

    // SamplePhoto for ScanTask
    message SamplePhoto {
      // Title/description of the photo
      string title = 1;
      // URL pointing to the photo
      string url = 2;
    }

    // List of sample photos as guides for the task
    repeated SamplePhoto sample_photos = 6;

    // Scan Location ID
    string scan_location_id = 7;
    // Scan Location Name
    string scan_location_name = 8;

    // Camera pitch threshold upper bound
    google.protobuf.DoubleValue pitch_upper_bound = 10;
    // Camera pitch threshold lower bound
    google.protobuf.DoubleValue pitch_lower_bound = 11;
    // Slope for the angle detection linear regression calculation
    google.protobuf.DoubleValue angle_detection_slope_threshold = 12;
    // R^2 for the angle detection linear regression calculation
    google.protobuf.DoubleValue angle_detection_r_squared_threshold = 13;
    // Minimum shelf tag width. Anything lower than this will be filtered out and not treated as shelf tags
    google.protobuf.DoubleValue min_shelf_tag_width = 14;
    // Minimum median shelf tag width. We will show a too far error when the median width is below this value.
    google.protobuf.DoubleValue min_median_shelf_tag_width = 15;
    // Maximum median shelf tag width. We will show a too close error when the median width is below this value.
    google.protobuf.DoubleValue max_median_shelf_tag_width = 16;
    // Percentage of the clear tags needed to pass the blurriness check
    google.protobuf.DoubleValue clear_tag_percentage_threshold = 17;
    // Controls whether to ask user to take half shelf photos
    google.protobuf.BoolValue enable_half_shelf_mode = 18;
    // Controls whether to switch to half shelf scanning on error
    google.protobuf.BoolValue switch_to_half_shelf_on_error = 19;
  }

  // Scan Tasks
  repeated ScanTask scan_tasks = 4;

  // When this response was generated
  google.protobuf.Timestamp created_at = 5;
}

// UploadScanDataRequest
message UploadScanDataRequest {
  reserved 8;
  reserved "device_info";

  // list of shelf tag data
  google.protobuf.StringValue shelf_tags = 1;
  // image_data of the scan
  google.protobuf.StringValue image_data = 2;
  // store_id of the event
  google.protobuf.StringValue store_id = 3;
  // scan mode
  google.protobuf.StringValue scan_mode = 4;
  // metadata
  google.protobuf.StringValue metadata = 5;
  // list of product data
  google.protobuf.StringValue products = 6;
  // session ID (task_id or ops generated ids)
  google.protobuf.StringValue session_id = 7;
  // dasher_id
  google.protobuf.StringValue dasher_id = 9;
  // device_model
  google.protobuf.StringValue device_model = 10;
  // Feature set bitflag
  int64 feature_set = 11;
  // Test request id, this can be empty (if coming from Upload BFF), or non-empty (if coming from Test Framework request
  // replay. This field helps associate test request and will propagate throughout the results stemming from this
  // request. This helps result tracking and comparison
  google.protobuf.StringValue test_request_id = 12;
}

// UploadScanDataResponse
message UploadScanDataResponse {
  // Status of the upload
  google.rpc.Status status = 1;
  // Response message
  google.protobuf.StringValue message = 2;
}

// CreateJetsScanTaskRequest
message CreateJetsScanTaskRequest {
  reserved 3;
  reserved "start_fulfillment_execution_request";

  // store ID
  google.protobuf.StringValue store_id = 1;
  // optional scan location IDs associated with this task. A scan location can be an aisle, wall, counter, etc.
  repeated google.protobuf.StringValue scan_location_ids = 2;
  // Request ID for the task (UUID)
  google.protobuf.StringValue request_id = 4;

  // Source to identify the caller. If you are creating a new caller of CreateJetsScanTask, add it here
  enum CreateJetsScanTaskRequestSource {
    // Error Scenario
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_UNSPECIFIED = 0;
    // Automated scan strategy within ground truth
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_AUTOMATED_SCAN_STRATEGY = 1;
    // CreateJetsScanTask Bulk Tool
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_BULK_TOOL = 2;
    // Cadence Task Coordinator Workflow
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_TASK_COORDINATOR_WORKFLOW = 3;
    // Store Directory Workflow
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_STORE_DIRECTORY_WORKFLOW = 4;
    // Task Console UI
    CREATE_JETS_SCAN_TASK_REQUEST_SOURCE_TASK_CONSOLE_UI = 5;
  }

  // Optional source to identify the caller for logging purposes
  CreateJetsScanTaskRequestSource source = 5;
  // Whether to use bootstrap logic for this request
  google.protobuf.BoolValue enable_bootstrap = 6;

  // If set to true will skip calling task service, used for test requests
  google.protobuf.BoolValue disable_task_fulfillment = 7;
  // UUID to correlate a group of requests
  google.protobuf.StringValue group_id = 8;
  // Will wait this much time before requesting a Dx to fulfill the task
  google.protobuf.Int64Value task_fulfillment_delay_in_seconds = 9;
}

// CreateJetsScanTaskV2Request
message CreateJetsScanTaskV2Request {
  // store ID
  google.protobuf.StringValue store_id = 1;
  // optional scan location IDs associated with this task. A scan location can be an aisle, wall, counter, etc.
  repeated google.protobuf.StringValue scan_location_ids = 2;
  // Request ID for the task (UUID)
  google.protobuf.StringValue request_id = 3;

  // Optional source to identify the caller for logging purposes
  CreateJetsScanTaskRequest.CreateJetsScanTaskRequestSource source = 4;
  // Whether to use bootstrap logic for this request
  google.protobuf.BoolValue enable_bootstrap = 5;

  // If set to true will skip calling task service, used for test requests
  google.protobuf.BoolValue disable_task_fulfillment = 6;
  // UUID to correlate a group of requests
  google.protobuf.StringValue group_id = 7;
  // Will wait this much time before requesting a Dx to fulfill the task
  google.protobuf.Int64Value task_fulfillment_delay_in_seconds = 8;
}

// CreateJetsScanTaskV2Response
message CreateJetsScanTaskV2Response {
  // Status of the task creation
  // Emulates the google.rpc.Status proto which is incompatible with Unified Gateway
  enum TaskCreationStatus {
    // Error scenario
    TASK_CREATION_STATUS_UNSPECIFIED = 0;
    // Task created successfully
    TASK_CREATION_STATUS_SUCCESS = 1;
    // Task creation failed
    TASK_CREATION_STATUS_FAILED = 2;
    // Task creation is pending
    TASK_CREATION_STATUS_PENDING = 3;
  }

  // Status of the task creation
  // Emulates the google.rpc.Status proto which is incompatible with Unified Gateway
  TaskCreationStatus status = 1;
  // Error message (won't be set for successes)
  google.protobuf.StringValue error_message = 2;
  // Wrapped StartFulfillmentExecutionResponse for callers that need it
  fuflillment_gateway.v1.StartFulfillmentExecutionResponse start_fulfillment_execution_response = 3;
  // Passes back request id from request in case caller did not provide one, for their logging purposes
  google.protobuf.StringValue request_id = 4;
}

// CreateJetsScanTaskResponse
message CreateJetsScanTaskResponse {
  // Status of the task creation
  google.rpc.Status status = 1;
  // Error message (won't be set for successes)
  google.protobuf.StringValue error_message = 2;
  // Wrapped StartFulfillmentExecutionResponse for callers that need it
  fuflillment_gateway.v1.StartFulfillmentExecutionResponse start_fulfillment_execution_response = 3;
  // Passes back request id from request in case caller did not provide one, for their logging purposes
  google.protobuf.StringValue request_id = 4;
}

// Request object for ProcessINFP endpoint
// Only one of business_ids or store_ids parameters should be specified
message ProcessINFPRequest {
  // List of Business ID to process INFP run on
  repeated int64 business_ids = 1;
  // List of Store IDs to process INFP run on
  repeated int64 store_ids = 2;
}

// Response object for ProcessINFP endpoint
message ProcessINFPResponse {
  // Success status of the triggered INFP run
  bool success = 1;
}

// Request object for ProcessINFPItem endpoint
// All items specified should be part of the same business and store
// One badge type is applied to all items per request
message ProcessINFPItemRequest {
  reserved 3; // Reserve the field number
  reserved "merchant_supplied_item_id";
  // Business ID of item(s) to process
  int64 business_id = 1;
  // Store ID of item(s) to process
  int64 store_id = 2;
  // The badge type to specify for these items
  enum StockLevel {
    // unspecified
    STOCK_LEVEL_UNSPECIFIED = 0;
    // in stock
    STOCK_LEVEL_IN_STOCK = 1;
    // low stock
    STOCK_LEVEL_LOW_STOCK = 2;
    // The item is high in stock
    STOCK_LEVEL_HIGH_STOCK = 3;
    // The item is out of stock
    STOCK_LEVEL_OUT_OF_STOCK = 4;
  }
  // The badge type to specify for these items
  StockLevel stock_level = 4;
  // The merchant supplied item ids to process INFP run on
  repeated string merchant_supplied_item_ids = 5;
}

// Response object for ProcessINFP item endpoint
message ProcessINFPItemResponse {
  // Success status of the triggered INFP item processing
  bool success = 1;
}

// Bounding Box format. Follows xywh format.
message BoundingBoxV2 {
  // X coordinate of the bounding box center
  double x = 1;
  // Y coordinate of the bounding box center
  double y = 2;
  // Width of the bounding box
  double w = 3;
  // Height of the bounding box
  double h = 4;
}

// Container for generic object, which can be image or zip file
message ObjectMetadata {
  // Object name
  google.protobuf.StringValue object_name = 1;
  // type of the object
  enum ObjectType {
    // Error Scenario
    OBJECT_TYPE_UNSPECIFIED = 0;
    // Image
    OBJECT_TYPE_IMAGE = 1;
    // Shelf tag image zip
    OBJECT_TYPE_SHELF_TAG_IMAGE_ZIP = 2;
    // Product image zip
    OBJECT_TYPE_PRODUCT_IMAGE_ZIP = 3;
  }
  // Object Type
  ObjectType object_type = 2;
  // Object URL
  google.protobuf.StringValue object_url = 3;
  // Object Size
  google.protobuf.Int64Value size_in_bytes = 4;
  // type of file
  enum FileType {
    // Error Scenario
    FILE_TYPE_UNSPECIFIED = 0;
    // Zip
    FILE_TYPE_ZIP = 1;
    // Image
    FILE_TYPE_IMAGE = 2;
    // Image heif
    FILE_TYPE_IMAGE_HEIF = 3;
  }
  // File Type
  FileType file_type = 5;
}

// Image Metadata
message ImageMetadata {
  // width in pixels
  google.protobuf.Int32Value width = 1;
  // height in pixels
  google.protobuf.Int32Value height = 2;
  // image file info
  ObjectMetadata image_file_info = 3;
  // shelf tag files info (this should be a zip of all shelf tag images)
  ObjectMetadata shelf_tag_files_info = 4;
  // product files info (this should be a zip of all product images)
  ObjectMetadata product_files_info = 5;
  // shelf tag and product image association. this connects tag id with product image id. first id is shelf tag id
  // second id is product image id. there's no enforcement on 1:N, 1:1, or N:1 relationship here, although,
  // tag id could map to multiple product image ids, but product image id mapping to multiple tag ids is not expected
  // (but not forbidden)
  repeated GTPair shelf_tag_product_image_associations = 6;
}

// Event Metadata
message EventMetadata {
  // source image metadata
  ImageMetadata source_image_metadata = 1;
  // bounding box map. map from shelf tag id to bounding box for that shelf tag
  map<string, BoundingBoxV2> shelftag_bounding_box_map = 2;
  // event location info. each image is collected at a specific location. we don't need to have
  // location info for each shelf tag. this saves space
  LocationInfo location_info = 3;
  // shelf tag and product image association. this connects tag id with product image id. first id is shelf tag id
  // second id is product image id. there's no enforcement on 1:N, 1:1, or N:1 relationship here, although,
  // tag id could map to multiple product image ids, but product image id mapping to multiple tag ids is not expected
  // (but not forbidden)
  repeated GTPair shelf_tag_product_image_association = 4;
}

// Pair of values, a generic helper data structure in GT
message GTPair {
  // first id
  google.protobuf.StringValue first = 1;
  // second id
  google.protobuf.StringValue second = 2;
}

// Availability Info for a shelf tag item
message AvailabilityInfo {
  // Types of availability
  enum Availability {
    // Unspecified availability
    AVAILABILITY_UNSPECIFIED = 0;
    // Product is in stock
    AVAILABILITY_IN_STOCK = 1;
    // Product is out of stock
    AVAILABILITY_OUT_OF_STOCK = 2;
  }
  // Availability. If null, then we don't have a determination either way
  Availability availability = 1;
  // Confidence, can be null if not available
  google.protobuf.DoubleValue confidence = 2;
}

// Product Image Info for image bounding box
message ProductImageInfo {
  // Product Image ID, this is identifier of a region, not the msid itself. It should be the same as the
  // shelf_tag_id of the corresponding shelf tag in the same image
  google.protobuf.StringValue product_image_id = 1;
  // Bounding box for product image. Note, the bounding box coordinate is in percentage, so need the dimension of
  // encapsulating image for this to be usable
  BoundingBoxV2 bounding_box = 2;
  // product image name
  google.protobuf.StringValue product_image_name = 3;
  // isEmptySpace
  google.protobuf.BoolValue is_empty_space = 4;
}

// Shelf Tag Info
message ShelfTagInfo {
  // Shelf tag id. This uniquely identifies the shelf tag in the context of the image. We don't enforce
  // the type, but convention is just use integer from 0
  google.protobuf.StringValue shelf_tag_id = 1;
  // Original shelf tag barcode info
  BarcodeInfo original_barcode_info = 2;
  // Resolved item info from barcode
  ItemInfo resolved_item_info = 3;
  // Availability info
  AvailabilityInfo resolved_availability_info = 4;
  // Bounding box. Note, the bounding box coordinate is in percentage, so need the dimension of
  // encapsulating image for this to be usable
  BoundingBoxV2 bounding_box = 5;
  // shelf tag image name
  google.protobuf.StringValue shelf_tag_image_name = 6;
  // Candidate item info list
  repeated ItemInfo candidate_item_info_list = 7;
  // Is partial (shelf tag is partially visible)
  google.protobuf.BoolValue is_partial = 8;
}

// Product Image Search Info
message ProductImageSearchInfo {
  // Product Image Info
  ProductImageInfo product_image_info = 1;
  // Image Search Item Info
  ImageSearchItemInfo image_search_item_info = 2;
}

// Image Search Item Info
message ImageSearchItemInfo {
  // msid
  google.protobuf.StringValue msid = 1;
  // Confidence, can be null if not available
  google.protobuf.DoubleValue confidence = 2;
  // Source
  google.protobuf.StringValue source = 3;
}

// Item Info
message ItemInfo {
  // Item ID
  google.protobuf.StringValue item_id = 1;
  // Item Name
  google.protobuf.StringValue item_name = 2;
  // Confidence, can be null if not available
  google.protobuf.DoubleValue confidence = 3;
  // Source
  google.protobuf.StringValue source = 4;
  // OCR text. raw OCR text
  google.protobuf.StringValue ocr_text = 5;
}

// Barcode Info
message BarcodeInfo {
  // Barcode
  google.protobuf.StringValue barcode = 1;
  // Barcode Type
  google.protobuf.StringValue barcode_type = 2;
}

// Location info. This should be provided at the image level
message LocationInfo {
  // location ID
  google.protobuf.StringValue location_id = 1;
  // canonical location name. This is the official name of the item location at time of scan
  google.protobuf.StringValue canonical_location_name = 2;
}

// Jets Processed Scan Image Data. This is exposed to external teams.
message JetsProcessedScanImageData {
  reserved 18;
  reserved "processed_product_image_result";
  reserved 24;
  reserved "product_image_search_results";
  // domain name
  google.protobuf.StringValue domain_name = 1;
  // namespace
  google.protobuf.StringValue namespace = 2;
  // store id
  google.protobuf.StringValue store_id = 3;
  // signal create time stamp
  google.protobuf.Timestamp signal_create_time_stamp = 4;
  // original event id. Identifies the original image that was processed
  google.protobuf.StringValue event_id = 5;
  // process result id. Identifies the result of a particular processing
  google.protobuf.StringValue process_result_id = 6;
  // session id. Identifies the session of activity (e.g. Dx scan) that created the original image
  google.protobuf.StringValue session_id = 7;
  // data version. will deprecate this field due to lack of readability
  google.protobuf.StringValue data_version = 8;
  // last updated at
  google.protobuf.Timestamp last_updated_at = 9;
  // last updated by
  google.protobuf.StringValue last_updated_by = 10;
  // image metadata
  ImageMetadata image_metadata = 11;
  // location info
  LocationInfo location_info = 12;
  // processed shelf tag info
  JetsProcessedShelfTagResults processed_shelf_tag_results = 13;
  // image metadata json
  google.protobuf.StringValue image_metadata_json = 14;
  // location info json
  google.protobuf.StringValue location_info_json = 15;
  // processed shelf tag info json
  google.protobuf.StringValue processed_shelf_tag_results_json = 16;
  // model version MAYBE deprecated in favor of version_objects. Discuss with Jets before use
  google.protobuf.StringValue model_version = 17;
  // processed product image info
  JetsProcessedProductImageResult processed_product_image_results = 19;
  // processed product image info json
  google.protobuf.StringValue processed_product_image_results_json = 20;
  // save the raw shelf tag event json string
  google.protobuf.StringValue raw_shelf_tag_event_info_json = 21;
  // data version id. will replace data_version
  google.protobuf.Int64Value version_id = 22;
  // business id
  google.protobuf.StringValue business_id = 23;
  // product image search results json of JetsProductImageSearchResults
  google.protobuf.StringValue product_image_search_results_json = 25;
  // event source metadata
  EventSourceMetadata event_source_metadata = 26;
  // event source metadata json
  google.protobuf.StringValue event_source_metadata_json = 27;
}

// Metadata for the event source
message EventSourceMetadata {
  // use case
  google.protobuf.StringValue use_case = 1;
  // dasher ID
  google.protobuf.StringValue dasher_id = 2;
  // merchant supplied item ID
  google.protobuf.StringValue merchant_supplied_item_id = 3;
  // Event source
  EventSource event_source = 4;
}

// Event Source
enum EventSource {
  // Unspecified event source
  EVENT_SOURCE_UNSPECIFIED = 0;
  // Full shelf tag photo event processor source
  EVENT_SOURCE_FULL_SHELF_TAG_PHOTO_EVENT_PROCESSOR = 1;
  // DXNV photo event processor event processor source
  EVENT_SOURCE_DX_NV_PHOTO_EVENT_PROCESSOR = 2;
}

// Shelf Tag Item Identification Intermediate Result. This is for internal storage object
message ShelfTagItemIdentificationIntermediateResult {
  // process result
  message ProcessResult {
    // process name
    google.protobuf.StringValue process_name = 1;
    // shelf tag result list
    repeated ShelfTagInfo shelf_tag_results = 2;
    // process time
    google.protobuf.Timestamp process_time = 3;
  }
  // map from process name to result
  map<string, ProcessResult> process_results = 1;
}

// Shelf Tag Item Identification. This is for internal storage object
message ShelfTagItemIdentificationFinalResult {
  // shelf tag result list
  repeated ShelfTagInfo shelf_tag_results = 1;
}

// Processed Shelf Tag Results. This is for external usage
message JetsProcessedShelfTagResults {
  // all processed shelf tag info
  repeated ShelfTagInfo shelf_tag_info = 1;
  // version objects for results
  repeated VersionObject version_objects = 2;
}

// Processed Product Image Results. This is for external usage
message JetsProcessedProductImageResult {
  // all processed product image info
  repeated ProductImageInfo product_image_info = 1;
  // version objects for results
  repeated VersionObject version_objects = 2;
}

// Processed Product Image Search Results. This is for external usage
message JetsProductImageSearchResults {
  // identified product image info
  repeated ProductImageSearchInfo product_image_search_info = 1;
  // version objects for results
  repeated VersionObject version_objects = 2;
}

// Perform Visual Search Request
message PerformVisualSearchRequest {
  // image data
  google.protobuf.BytesValue image_data = 1;
  // OCR data
  google.protobuf.StringValue ocr_data = 2;
  // metadata
  google.protobuf.StringValue metadata = 3;
  // base64 image data string
  google.protobuf.StringValue image = 4;
}

// Perform Visual Search Response
message PerformVisualSearchResponse {
  reserved 1;
  reserved "status";
  // Response message
  google.protobuf.StringValue message = 2;
  // Response payload
  google.protobuf.StringValue payload = 3;
}

// Upload Visual Aisles Image Request
message UploadVisualAislesImagesRequest {
  // business id
  google.protobuf.StringValue business_id = 1;
  // store id
  google.protobuf.StringValue store_id = 2;
  // list of files
  repeated File files = 3;
  // folder type
  VisualAislesFolderType folder_type = 4;
}

// Upload Visual Aisles Image Response
message UploadVisualAislesImagesResponse {}

// Get Visual Aisles Images Request
message GetVisualAislesImagesRequest {
  // business id
  google.protobuf.StringValue business_id = 1;
  // store id
  google.protobuf.StringValue store_id = 2;
  // content types
  repeated VisualAislesContentType content_types = 3;
  // folder types
  repeated VisualAislesFolderType folder_types = 4;
  // time interval
  TimeInterval time_interval = 5;
}

// Get Visual Aisles Images Response
message GetVisualAislesImagesResponse {
  // list of visual aisles images
  repeated VisualAislesImage images = 1;
}

// Visual Aisles Image
message VisualAislesImage {
  reserved 6;
  reserved "image_bounding_box";
  // image uuid
  google.protobuf.StringValue image_uuid = 1;
  // image url
  google.protobuf.StringValue image_url = 2;
  // content type
  VisualAislesContentType image_content_type = 3;
  // metadata type: only set for visual aisles (operator) images
  VisualAislesFolderType image_metadata_type = 4;
  // timestamp
  google.protobuf.Int64Value timestamp = 5;
  // lightweight jets image data: only set for JETS images
  LightweightJetsImageData jets_image_data = 7;

  // light weight jets data for visual aisles tool
  message LightweightJetsImageData {
    // width in pixels
    google.protobuf.Int32Value width = 1;
    // height in pixels
    google.protobuf.Int32Value height = 2;
    // shelf tag info
    repeated ShelfTagInfo shelf_tag_info = 3;
    // all processed product image info
    repeated ProductImageInfo product_image_info = 4;
  }
}

// Visual Aisles Content Type
enum VisualAislesContentType {
  // Unspecified content type
  VISUAL_AISLES_CONTENT_TYPE_UNSPECIFIED = 0;
  // In Store content type
  VISUAL_AISLES_CONTENT_TYPE_IN_STORE = 1;
  // JETS content type
  VISUAL_AISLES_CONTENT_TYPE_IN_STORE_JETS = 2;
}

// Time Interval given in ms since January 1, 1970, 00:00:00 GMT
message TimeInterval {
  // start time
  google.protobuf.Int64Value start = 1;
  // end time
  google.protobuf.Int64Value end = 2;
}

// File object to used to upload to S3
message File {
  // content of the file
  bytes content = 1;
  // filename of the file
  string filename = 2;
}

// Visual Aisles Folder Type
enum VisualAislesFolderType {
  // Unspecified folder type
  VISUAL_AISLES_FOLDER_TYPE_UNSPECIFIED = 0;
  // Raw folder type
  VISUAL_AISLES_FOLDER_TYPE_RAW = 1;
  // Annotated folder type
  VISUAL_AISLES_FOLDER_TYPE_ANNOTATED = 2;
}

// Enum for operation type
enum OperationType {
  // Unspecified operation type
  OPERATION_TYPE_UNSPECIFIED = 0;
  // Machine Learning OCR
  OPERATION_TYPE_ML_OCR = 1;
  // Machine Learning Out Of Stock
  OPERATION_TYPE_ML_OOS = 2;
  // Machine Learning Visual Search
  OPERATION_TYPE_ML_VISUAL_SEARCH = 3;
  // Ground Truth Pipeline
  OPERATION_TYPE_GT_PIPELINE = 4;
}

// Version for ML model and application logic
message VersionObject {
  // Version
  google.protobuf.StringValue version = 1;
  // Operation type enums
  OperationType operation_type = 2;
}

// Create Ground Truth Task Request
message CreateGroundTruthTaskRequest {
  // Request ID associated with the task. This will act as IdempotencyKey when submitting the task to Task Platform
  google.protobuf.StringValue request_uuid = 1;
  // task-metadata for different types of tasks
  oneof task_metadata {
    // task metadata for area photos task
    AreaPhotosTaskRequestData area_photo_task_request_data = 2;
  }
}

// Create Ground Truth Task Response
message CreateGroundTruthTaskResponse {}

// Get Ground Truth Tasks Request
message GetGroundTruthTasksRequest {
  // task_id = task_group_id submitted to task-platform.
  // if this is present, all other filters are ignored
  google.protobuf.StringValue task_id = 1;
  // Getting JETS_SCAN_TASK entries with filter on store_id
  google.protobuf.StringValue store_id = 2;
  // Getting JETS_SCAN_TASK entries with filter on task_type
  TaskType task_type = 3;
  // Getting JETS_SCAN_TASK entries with filter on task_status
  google.protobuf.StringValue task_status = 4;
  // lookback period in hours
  google.protobuf.Int32Value lookback_period_hours = 5;
}

// Get Ground Truth Task Response
message GetGroundTruthTasksResponse {
  // list of ground truth tasks
  repeated GroundTruthTask ground_truth_tasks = 1;
}

// Enum for different scanning modes
enum ScanMode {
  // Default unspecified scan mode
  SCAN_MODE_UNSPECIFIED = 0;
  // Scanning through DX task flow
  SCAN_MODE_DX_TASK = 1;
  // Scanning through operations tool
  SCAN_MODE_OPS_TOOL = 2;
  // Scanning through merchant integration
  SCAN_MODE_MERCHANT = 3;
}

// Request for generating presigned scan URLs
message GetScanUrlsRequest {
  // ID of the store
  string store_id = 1;
  // The mode of scanning (e.g., ops tool, dasher task)
  ScanMode scan_mode = 2;
  // Maximum number of URLs to generate (default: 20)
  google.protobuf.Int32Value limit = 3;
}

// Response containing presigned scan URLs
message GetScanUrlsResponse {
  // List of scan URL objects
  repeated ScanUrlInfo scan_urls = 1;

  // Individual scan URL information
  message ScanUrlInfo {
    // Unique identifier for this presigned URL set
    string id = 1;
    // Presigned URL for the main image
    string image_url = 2;
    // Optional presigned URL for shelf tag images zip file
    google.protobuf.StringValue tags_images_url = 3;
  }
}
